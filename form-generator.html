<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Note Form Generator</title>
    <style>
      :root {
        --bg: #f7f9fc;
        --card: #ffffff;
        --text: #111216;
        --accent: #2b8cff;
        --muted: #666666;
        --border: #e9eef6;
        --panel: #fbfdff;
      }
      .dark {
        --bg: #0b1220;
        --card: #0f1724;
        --text: #e6eef8;
        --accent: #4aa3ff;
        --muted: #94a9c2;
        --border: #253244;
        --panel: #071226;
      }
      body {
        font-family: Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        margin: 0;
        background: var(--bg);
        color: var(--text);
        transition: background 0.18s, color 0.18s;
      }
      .container {
        max-width: 960px;
        margin: 28px auto;
        padding: 18px;
        background: var(--card);
        border-radius: 8px;
        box-shadow: 0 6px 18px rgba(2, 6, 23, 0.06);
      }
      .top {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .top {
        /* keep the header stable and prevent reflow when tabs change */
        position: sticky;
        top: 0;
        z-index: 3;
        padding-bottom: 8px;
      }
      .top h1 {
        flex: 0 0 auto;
      }
      .top-controls {
        display: flex;
        align-items: center;
        gap: 10px;
        flex: 0 0 auto;
        white-space: nowrap;
      }
      h1 {
        font-size: 18px;
        margin: 0;
      }
      .tabs {
        display: flex;
        gap: 6px;
        margin-top: 14px;
        border-bottom: 1px solid var(--border);
        overflow-x: auto;
        white-space: nowrap;
        -webkit-overflow-scrolling: touch;
      }
      .tab {
        padding: 10px 14px;
        cursor: pointer;
        border-radius: 6px 6px 0 0;
        color: var(--muted);
        flex: 0 0 auto;
      }
      .tab.right {
        margin-left: auto;
      }
      .tab.active {
        background: linear-gradient(180deg, #fff, #f4f8ff);
        color: var(--accent);
        box-shadow: 0 -4px 12px rgba(43, 140, 255, 0.06);
        border-bottom: 2px solid #fff;
      }
      .tab-content {
        padding: 18px;
      }
      .field {
        margin-bottom: 12px;
      }
      label {
        display: block;
        margin-bottom: 6px;
        font-weight: 600;
      }
      input[type='text'],
      input[type='number'],
      select,
      textarea {
        width: 100%;
        padding: 8px 10px;
        border: 1px solid var(--border);
        border-radius: 6px;
        background: transparent;
        color: var(--text);
      }
      .subtabs {
        display: flex;
        gap: 6px;
        margin-bottom: 12px;
      }
      .subtab {
        padding: 6px 10px;
        border-radius: 6px;
        background: transparent;
        border: 1px solid var(--border);
        cursor: pointer;
        color: var(--muted);
      }
      .subtab.active {
        background: var(--accent);
        color: #fff;
      }
      .btn {
        display: inline-block;
        padding: 8px 12px;
        border-radius: 6px;
        background: var(--accent);
        color: #fff;
        border: 0;
        cursor: pointer;
      }
      .btn.ghost {
        background: #f2f6ff;
        color: var(--accent);
        border: 1px solid #d7e7ff;
      }
      .meta {
        color: var(--muted);
        font-size: 13px;
      }
      .preview-list {
        border: 1px solid var(--border);
        padding: 10px;
        border-radius: 6px;
        background: var(--panel);
      }
      .preview-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 0;
        border-bottom: 1px dashed #f0f4fb;
      }
      .preview-item:last-child {
        border-bottom: none;
      }
      .small {
        font-size: 13px;
        color: #333;
      }
      /* Dev toggle switch */
      .switch {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        margin-left: 6px;
      }
      .switch input {
        display: none;
      }
      .switch .knob {
        width: 40px;
        height: 20px;
        background: #d7dbe0;
        border-radius: 20px;
        position: relative;
        transition: background 0.15s;
        box-shadow: inset 0 -2px 0 rgba(0,0,0,0.03);
      }
      .switch .knob::after {
        content: '';
        position: absolute;
        left: 3px;
        top: 3px;
        width: 14px;
        height: 14px;
        background: #fff;
        border-radius: 50%;
        transition: left 0.15s;
        box-shadow: 0 1px 2px rgba(2,6,23,0.08);
      }
      .switch input:checked + .knob {
        background: var(--accent);
      }
      .switch input:checked + .knob::after {
        left: 23px;
      }
      .switch .label {
        font-size: 13px;
        color: var(--muted);
        user-select: none;
      }
      .footer {
        margin-top: 12px;
        border-top: 1px solid var(--border);
        padding-top: 10px;
        text-align: center;
        font-size: 13px;
        color: var(--muted);
      }
      .footer-inner {
        max-width: 960px;
        margin: 0 auto;
        padding: 0 18px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="top">
        <h1>Inline JSON Form Generator</h1>
        <div class="top-controls">
          <button id="themeToggle" class="btn ghost" type="button" aria-label="Toggle dark mode">
            Dark
          </button>
        </div>
      </div>

      <div id="tabbar" class="tabs"></div>
      <div id="contents"></div>
    </div>
    <footer class="footer">
      <div class="footer-inner">
        <div class="meta">Copyright ©️ 2026 Valithor Obsidion &lt;valithor@discordphp.org&gt;</div>
      </div>
    </footer>

    <script>
      const formConfig = (window.formConfig && Array.isArray(window.formConfig))
        ? window.formConfig
        : [];

      // Keep a pristine copy of the original formConfig so we can restore defaults
      const originalFormConfig = JSON.parse(JSON.stringify(formConfig));

      const tabbar = document.getElementById('tabbar');
      const contents = document.getElementById('contents');

      // Dev mode toggle: when true, Templates pane and per-form Unload buttons are visible.
      // Persisted in localStorage key 'nfg-dev-mode'. Default is true to preserve current behavior.
      const devKey = 'nfg-dev-mode';
      let devMode = true;
      try {
        const s = localStorage.getItem(devKey);
        if (s !== null) devMode = s === 'true';
      } catch (e) {}

      // create a small Dev toggle switch next to theme toggle
      (function addDevToggleBtn() {
        try {
          const header = document.querySelector('.top > div');
          if (!header) return;
          const wrapper = document.createElement('label');
          wrapper.className = 'switch';
          wrapper.style.marginLeft = '6px';
          // inner structure: checkbox + knob + label
          wrapper.innerHTML = `<input id="devToggle" type="checkbox" ${devMode ? 'checked' : ''}><span class="knob"></span><span class="label">${devMode ? 'Dev On' : 'Dev Off'}</span>`;
          const checkbox = wrapper.querySelector('input');
          const textLabel = wrapper.querySelector('.label');
          function apply() {
            try { localStorage.setItem(devKey, devMode ? 'true' : 'false'); } catch (e) {}
            if (checkbox) checkbox.checked = devMode;
            if (textLabel) textLabel.textContent = devMode ? 'Dev On' : 'Dev Off';
            // Preserve all current form values across the rebuild so toggling
            // dev mode doesn't clear user input.
            const allPrev = {};
            try {
              Array.from(contents.querySelectorAll('.tab-pane')).forEach((pane) => {
                const idx = pane.dataset.index;
                const form = pane.querySelector('form.generated-form');
                if (!form) return;
                const map = {};
                Array.from(form.elements).forEach((e) => {
                  if (!e.name) return;
                  const name = e.name;
                  const val = e.type === 'checkbox' ? (e.checked ? e.value || 'on' : '') : e.value;
                  if (Object.prototype.hasOwnProperty.call(map, name)) {
                    if (!Array.isArray(map[name])) map[name] = [map[name]];
                    map[name].push(val);
                  } else {
                    map[name] = val;
                  }
                });
                allPrev[idx] = map;
              });
            } catch (e) {}
            try { build(); } catch (e) {}
            try {
              Object.keys(allPrev).forEach((idx) => {
                const pane = contents.querySelector(`.tab-pane[data-index='${idx}']`);
                if (!pane) return;
                const form = pane.querySelector('form.generated-form');
                if (!form) return;
                const prev = allPrev[idx] || {};
                Object.keys(prev).forEach((name) => {
                  try {
                    const els = Array.from(form.querySelectorAll(`[name="${CSS.escape(name)}"]`));
                    if (!els || els.length === 0) return;
                    const pv = prev[name];
                    if (els[0].type === 'radio') {
                      els.forEach((r) => (r.checked = r.value == pv));
                      return;
                    }
                    if (els[0].type === 'checkbox') {
                      els.forEach((c) => {
                        if (Array.isArray(pv)) c.checked = pv.includes(c.value);
                        else c.checked = !!pv && String(pv) !== 'false' && String(pv) !== '0';
                      });
                      return;
                    }
                    if (Array.isArray(pv)) {
                      for (let k = 0; k < els.length && k < pv.length; k++) els[k].value = pv[k];
                    } else {
                      els[0].value = pv;
                    }
                  } catch (e) {}
                });
              });
            } catch (e) {}
          }
          checkbox.addEventListener('change', () => {
            devMode = !!checkbox.checked;
            apply();
          });
          header.appendChild(wrapper);
          apply();
        } catch (e) {}
      })();

      // Build list of available templates (include JSON fallback)
      const defaultTemplates = [{ id: '__json__', label: 'JSON (full)', cfg: null }];
      // Create a default template entry for every tab so each tab has a template option
      formConfig.forEach((t, idx) => {
        const id = `tpl-${idx}`;
        const label = t.format && t.format.label ? t.format.label : `${t.title}`;
        const cfg = t.format ? t.format : null;
        defaultTemplates.push({ id, label, cfg });
        // keep a reference on the config so we can detect default when using defaults
        t._templateId = id;
      });

      // Load editable templates from localStorage if present, otherwise merge with defaults
      let templates;
      try {
        const saved = localStorage.getItem('nfg-templates');
        if (saved) {
          const parsed = JSON.parse(saved);
          if (Array.isArray(parsed)) {
            // Start from defaults and overlay saved entries (saved entries override defaults)
            const map = Object.fromEntries(defaultTemplates.map((t) => [t.id, t]));
            for (const s of parsed) {
              if (s && s.id) map[s.id] = s;
            }
            templates = Object.values(map);
          }
        }
      } catch (e) {}
      if (!templates) templates = defaultTemplates.slice();

      // map for quick lookup
      let templatesMap = Object.fromEntries(templates.map((x) => [x.id, x]));
      // key for persisting per-tab template selection (map index -> templateId)
      const templateMapKey = 'nfg-template-map';
      let templateMap = {};
      // try to load saved mapping and apply to formConfig
      try {
        const savedMap = localStorage.getItem(templateMapKey);
        if (savedMap) {
          const parsed = JSON.parse(savedMap);
          if (parsed && typeof parsed === 'object') {
            templateMap = parsed;
            Object.keys(parsed).forEach((k) => {
              const idx = Number(k);
              const id = parsed[k];
              if (!Number.isNaN(idx) && formConfig[idx] && templatesMap[id]) {
                formConfig[idx]._templateId = id;
              }
            });
          }
        }
      } catch (e) {}

      function persistTemplateMap() {
        try {
          const map = {};
          for (let i = 0; i < formConfig.length; i++) {
            if (formConfig[i] && formConfig[i]._templateId && templatesMap[formConfig[i]._templateId]) {
              map[i] = formConfig[i]._templateId;
            }
          }
          templateMap = map;
          localStorage.setItem(templateMapKey, JSON.stringify(map));
        } catch (e) {}
      }
      // counter used to give generated dynamic inputs unique ids
      let dynamicIdCounter = 0;
      // when true, tpl select change handlers should not activate tabs (used during programmatic updates)
      let suppressTabActivation = false;

      // Create a step row (key input + value input + remove button) and append to `list`.
      // `baseName` is the field name, `keyVal` can be a string value or {key,val}.
      function createStepRow(baseName, keyVal, container, list) {
        const kv = { key: '', val: '' };
        if (keyVal && typeof keyVal === 'object') {
          kv.key = keyVal.key || '';
          kv.val = keyVal.val || '';
        } else if (typeof keyVal === 'string') {
          kv.val = keyVal;
        }

        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.gap = '8px';
        row.style.marginTop = '6px';

        const keyInp = document.createElement('input');
        keyInp.type = 'text';
        keyInp.name = baseName + '_key';
        keyInp.placeholder = 'key';
        keyInp.style.width = '80px';

        let defaultKey = kv.key || '';
        if (!defaultKey && container && container.dataset) {
            if (container.dataset.keyMode === 'numbered') {
              const existing = list.querySelectorAll(`[name="${baseName}"]`);
              defaultKey = String(existing.length + 1) + '.';
            } else if (container.dataset.keyMode === 'bullet') {
              defaultKey = '-';
            }
        }
        keyInp.value = defaultKey;

        const inp = document.createElement('input');
        inp.type = 'text';
        inp.name = baseName;
        inp.id = baseName + '-' + ++dynamicIdCounter;
        inp.placeholder = 'Step';
        if (kv.val) inp.value = kv.val;

        const remove = document.createElement('button');
        remove.type = 'button';
        remove.className = 'btn ghost';
        remove.textContent = '-';
        remove.addEventListener('click', () => {
          row.remove();
        });

        row.appendChild(keyInp);
        row.appendChild(inp);
        row.appendChild(remove);
        if (list) list.appendChild(row);
        return inp;
      }

      function build() {
        tabbar.innerHTML = '';
        contents.innerHTML = '';
        formConfig.forEach((tab, i) => {
          const t = document.createElement('div');
          t.className = 'tab';
          t.textContent = tab.title;
          t.dataset.index = i;
          t.addEventListener('click', () => activateTab(i));
          tabbar.appendChild(t);

          const pane = document.createElement('div');
          pane.className = 'tab-pane';
          pane.style.display = 'none';
          pane.dataset.index = i;

          // subtabs: Form and Populate
          const subtabs = document.createElement('div');
          subtabs.className = 'subtabs';
          const stForm = document.createElement('div');
          stForm.className = 'subtab active';
          stForm.textContent = 'Form';
          const stPop = document.createElement('div');
          stPop.className = 'subtab';
          stPop.textContent = 'Populate';
          subtabs.appendChild(stForm);
          subtabs.appendChild(stPop);
          pane.appendChild(subtabs);

          const formArea = document.createElement('div');
          formArea.className = 'tab-content form-area';
          const populateArea = document.createElement('div');
          populateArea.className = 'tab-content populate-area';
          populateArea.style.display = 'none';

          // build form
          const form = document.createElement('form');
          form.className = 'generated-form';
          tab.fields.forEach((f) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'field';
            const label = document.createElement('label');
            label.textContent = f.label || f.name;
            wrapper.appendChild(label);

            let input;
            if (f.type === 'textarea') {
              input = document.createElement('textarea');
              input.rows = 4;
            } else if (f.type === 'select') {
              input = document.createElement('select');
              (f.options || []).forEach((opt) => {
                const o = document.createElement('option');
                o.value = opt.value ?? opt;
                o.textContent = opt.label ?? opt;
                input.appendChild(o);
              });
            } else {
              input = document.createElement('input');
              input.type = f.type || 'text';
            }
            input.name = f.name;
            input.placeholder = f.placeholder || '';
            if (f.default) input.value = f.default;
            wrapper.appendChild(input);
            // Special handling for steps type: build dynamic list UI
            if (f.type === 'steps') {
              // Rename the top input to be the combined input so it does not
              // conflict with the per-step inputs below (which share the base name).
              input.name = f.name + '_combined';
              input.placeholder = 'Step 1 > Step 2 > Step 3';
              input.style.width = '70%';
              input.style.display = 'inline-block';

              const parseBtnTop = document.createElement('button');
              parseBtnTop.type = 'button';
              parseBtnTop.className = 'btn ghost';
              parseBtnTop.textContent = 'Parse';
              parseBtnTop.style.marginLeft = '8px';
              // place the combined input and button inside a row
              const combinedRow = document.createElement('div');
              combinedRow.style.display = 'flex';
              combinedRow.style.alignItems = 'center';
              combinedRow.style.gap = '8px';
              combinedRow.appendChild(input);
              combinedRow.appendChild(parseBtnTop);
              // If the field defines a default combined steps string, prefill and parse it
              if (f.default && typeof f.default === 'string' && f.default.trim()) {
                input.value = f.default;
              }
              wrapper.appendChild(combinedRow);
              if (f.default && typeof f.default === 'string' && f.default.trim()) {
                // trigger parse to populate individual step rows
                parseBtnTop.click();
              }
              // default key behavior selector (none | numbered)
              const controlRow = document.createElement('div');
              controlRow.style.display = 'flex';
              controlRow.style.alignItems = 'center';
              controlRow.style.gap = '8px';
              controlRow.style.marginTop = '8px';
              const modeLabel = document.createElement('div');
              modeLabel.className = 'meta';
              modeLabel.textContent = 'Default key:';
              const modeSelect = document.createElement('select');
              const oNone = document.createElement('option');
              oNone.value = 'none';
              oNone.textContent = 'None (blank)';
              const oNum = document.createElement('option');
              oNum.value = 'numbered';
              oNum.textContent = 'Numbered';
              const oBullet = document.createElement('option');
              oBullet.value = 'bullet';
              oBullet.textContent = 'Bullet (-)';
              modeSelect.appendChild(oNone);
              modeSelect.appendChild(oNum);
              modeSelect.appendChild(oBullet);
              modeSelect.value = 'none';
              modeSelect.addEventListener('change', () => {
                container.dataset.keyMode = modeSelect.value;
              });
              controlRow.appendChild(modeLabel);
              controlRow.appendChild(modeSelect);
              wrapper.appendChild(controlRow);
              const container = document.createElement('div');
              container.className = 'steps-container';
              container.dataset.name = f.name;
              // initialize key mode on the container after it's created
              container.dataset.keyMode = modeSelect.value;

              const list = document.createElement('div');
              list.className = 'steps-list';

              const addBtn = document.createElement('button');
              addBtn.type = 'button';
              addBtn.className = 'btn ghost';
              addBtn.textContent = '+ Add';
              addBtn.style.marginLeft = '8px';

              function addPathItem(val) {
                // val can be a string value or an object { key, val }
                const keyVal = { key: '', val: '' };
                if (val && typeof val === 'object') {
                  keyVal.key = val.key || '';
                  keyVal.val = val.val || '';
                } else if (typeof val === 'string') {
                  keyVal.val = val;
                }
                return createStepRow(f.name, keyVal, container, list);
              }

              // ensure at least one item exists so scanPopulate can detect the name
              addPathItem('');

              addBtn.addEventListener('click', () => addPathItem(''));
              // parse top combined input into steps
              parseBtnTop.addEventListener('click', () => {
                const parts = (input.value || '')
                  .split('>')
                  .map((s) => s.trim())
                  .filter(Boolean);
                list.innerHTML = '';
                if (parts.length === 0) {
                  addPathItem('');
                } else {
                  parts.forEach((p) => {
                    if (p.includes('=>')) {
                          const [k, ...rest] = p.split('=>');
                          const val = rest.join('=>').trim();
                          // When parsing a numbered key like "1" from a combined
                          // steps string, add the period so the per-step key field
                          // reflects the numbered style ("1."). If the key already
                          // included punctuation, preserve it.
                          let key = k.trim();
                          if (/^\d+$/.test(key)) key = key + '.';
                          addPathItem({ key, val });
                        } else {
                          addPathItem(p);
                        }
                  });
                }
              });
              wrapper.appendChild(container);
              container.appendChild(list);
              container.appendChild(addBtn);
              form.appendChild(wrapper);
            } else {
              form.appendChild(wrapper);
            }
          });

          // top-of-page clear button for this tab's form
          const topClear = document.createElement('button');
          topClear.className = 'btn ghost';
          topClear.type = 'button';
          topClear.textContent = 'Clear Form';
          topClear.style.marginBottom = '8px';
          topClear.addEventListener('click', () => {
            Array.from(form.elements).forEach((e) => {
              if (!e.name) return;
              try {
                if (e.type === 'checkbox' || e.type === 'radio') e.checked = false;
                else e.value = '';
              } catch (err) {}
            });
          });
          formArea.appendChild(topClear);
          formArea.appendChild(form);

          // template selector
          const tplRow = document.createElement('div');
          tplRow.style.display = 'flex';
          tplRow.style.alignItems = 'center';
          tplRow.style.gap = '8px';
          tplRow.style.marginTop = '6px';
          const tplLabel = document.createElement('div');
          tplLabel.className = 'meta';
          tplLabel.textContent = 'Template:';
          const tplSelect = document.createElement('select');
          tplSelect.style.padding = '6px';
          tplSelect.style.borderRadius = '6px';
          tplSelect.style.border = '1px solid var(--border)';
          templates.forEach((tpl) => {
            const o = document.createElement('option');
            o.value = tpl.id;
            o.textContent = tpl.label;
            tplSelect.appendChild(o);
          });
          // default to this tab's configured template if present
          if (formConfig[i] && formConfig[i]._templateId)
            tplSelect.value = formConfig[i]._templateId;
          // when a template is selected, apply its fields and cfg to this tab and rebuild
          tplSelect.addEventListener('change', () => {
            const sel = tplSelect.value || '__json__';
            const tpl = templatesMap[sel];
            if (!tpl) return;
            // capture current values to avoid losing user input on rebuild
            const prevValues = {};
            try {
              Array.from(form.elements).forEach((e) => {
                if (!e.name) return;
                const name = e.name;
                const val = e.type === 'checkbox' ? (e.checked ? e.value || 'on' : '') : e.value;
                if (Object.prototype.hasOwnProperty.call(prevValues, name)) {
                  if (!Array.isArray(prevValues[name])) prevValues[name] = [prevValues[name]];
                  prevValues[name].push(val);
                } else {
                  prevValues[name] = val;
                }
              });
            } catch (e) {}
            try {
              if (Array.isArray(tpl.fields) && tpl.fields.length) {
                formConfig[i].fields = JSON.parse(JSON.stringify(tpl.fields));
              }
              if (tpl.cfg) {
                formConfig[i].format = JSON.parse(JSON.stringify(tpl.cfg));
              }
            } catch (e) {}
            try {
              formConfig[i]._templateId = sel;
              persistTemplateMap();
            } catch (e) {}
            const preserveIndex = i;
            build();
            try {
              // restore preserved values into rebuilt pane
              if (!suppressTabActivation) activateTab(Number(preserveIndex));
              const newPane = contents.querySelector(`.tab-pane[data-index='${preserveIndex}']`);
              if (newPane) {
                const newForm = newPane.querySelector('form.generated-form');
                if (newForm) {
                  Object.keys(prevValues).forEach((name) => {
                    try {
                      const els = Array.from(newForm.querySelectorAll(`[name="${CSS.escape(name)}"]`));
                      if (!els || els.length === 0) return;
                      const pv = prevValues[name];
                      if (els[0].type === 'radio') {
                        els.forEach((r) => (r.checked = r.value == pv));
                        return;
                      }
                      if (els[0].type === 'checkbox') {
                        els.forEach((c) => {
                          if (Array.isArray(pv)) c.checked = pv.includes(c.value);
                          else c.checked = !!pv && String(pv) !== 'false' && String(pv) !== '0';
                        });
                        return;
                      }
                      if (Array.isArray(pv)) {
                        for (let k = 0; k < els.length && k < pv.length; k++) els[k].value = pv[k];
                      } else {
                        els[0].value = pv;
                      }
                    } catch (e) {}
                  });
                }
              }
            } catch (e) {}
          });
          tplRow.appendChild(tplLabel);
          tplRow.appendChild(tplSelect);
          // if dev mode is enabled, expose an Unload button for this form
          if (devMode) {
            const unloadBtn = document.createElement('button');
            unloadBtn.type = 'button';
            unloadBtn.className = 'btn ghost';
            unloadBtn.textContent = 'Unload';
            unloadBtn.style.marginLeft = '8px';
            unloadBtn.addEventListener('click', () => {
              try {
                const tid = formConfig[i] && formConfig[i]._templateId;
                if (tid && /^tpl-(\d+)$/.test(tid)) {
                  alert('Cannot unload a default form tab.');
                  return;
                }
                // remove this form tab
                formConfig.splice(i, 1);
                try { persistTemplateMap(); } catch (e) {}
                build();
                try { activateTab(Math.max(0, i - 1)); } catch (e) {}
              } catch (e) {}
            });
            tplRow.appendChild(unloadBtn);
          }
          formArea.appendChild(tplRow);

          // --- Generate UI: button + output area
          const genWrapper = document.createElement('div');
          genWrapper.style.marginTop = '12px';
          const genBtn = document.createElement('button');
          genBtn.className = 'btn';
          genBtn.type = 'button';
          genBtn.textContent = 'Generate';
          const copyBtn = document.createElement('button');
          copyBtn.className = 'btn ghost';
          copyBtn.type = 'button';
          copyBtn.textContent = 'Copy';
          copyBtn.style.marginLeft = '8px';
          const clearOutBtn = document.createElement('button');
          clearOutBtn.className = 'btn ghost';
          clearOutBtn.type = 'button';
          clearOutBtn.textContent = 'Clear';
          clearOutBtn.style.marginLeft = '8px';
          const out = document.createElement('textarea');
          out.readOnly = true;
          out.rows = 3;
          out.style.width = '100%';
          out.style.marginTop = '8px';
          out.style.padding = '8px';
          out.style.borderRadius = '6px';
          out.style.border = '1px solid #eee';
          genWrapper.appendChild(genBtn);
          genWrapper.appendChild(copyBtn);
          genWrapper.appendChild(clearOutBtn);
          genWrapper.appendChild(out);
          formArea.appendChild(genWrapper);

          genBtn.addEventListener('click', () => {
            const values = {};
            Array.from(form.elements).forEach((e) => {
              if (!e.name) return;
              const v = e.value !== undefined ? e.value : '';
              if (Object.prototype.hasOwnProperty.call(values, e.name)) {
                if (!Array.isArray(values[e.name])) values[e.name] = [values[e.name]];
                values[e.name].push(v);
              } else {
                values[e.name] = v;
              }
            });
            // Combine key=>value pairs for fields that have an associated _key input
            Object.keys(values).forEach((k) => {
              if (!k.endsWith('_key')) return;
              const base = k.slice(0, -4);
              if (!Object.prototype.hasOwnProperty.call(values, base)) return;
              const keys = Array.isArray(values[k]) ? values[k] : [values[k]];
              const vals = Array.isArray(values[base]) ? values[base] : [values[base]];
              const combined = vals.map((v, i) => {
                const keyRaw = keys[i] || '';
                let prefix = '';
                // Do not automatically append a period to numeric keys here;
                // only preserve what the user entered. If the key already
                // contains a period, it will be preserved.
                if (/^\d+$/.test(keyRaw)) prefix = keyRaw + ' ';
                else if (keyRaw) prefix = keyRaw + ' ';
                return prefix + v;
              });
              values[base] = combined.length === 1 ? combined[0] : combined;
              // optionally remove the keys entry
              delete values[k];
            });
            const sel = tplSelect.value || '__json__';
            const cfg = templatesMap[sel] && templatesMap[sel].cfg ? templatesMap[sel].cfg : null;
            out.value = generateOutput(cfg, values);
          });
          copyBtn.addEventListener('click', async () => {
            const text = out.value || '';
            try {
              if (navigator.clipboard && navigator.clipboard.writeText) {
                await navigator.clipboard.writeText(text);
              } else {
                out.select();
                document.execCommand('copy');
              }
              alert('Copied:\n' + text);
            } catch (err) {
              try {
                out.select();
                document.execCommand('copy');
                alert('Copied:\n' + text);
              } catch (e) {
                alert('Copy failed');
              }
            }
          });
          clearOutBtn.addEventListener('click', () => {
            out.value = '';
          });

          // populate area UI
          const info = document.createElement('div');
          info.className = 'meta';
          info.textContent = 'Scan other tabs for values with matching field names.';
          const scanBtn = document.createElement('button');
          scanBtn.className = 'btn ghost';
          scanBtn.type = 'button';
          scanBtn.textContent = 'Scan';
          const autoBtn = document.createElement('button');
          autoBtn.className = 'btn';
          autoBtn.type = 'button';
          autoBtn.style.marginLeft = '8px';
          autoBtn.textContent = 'Auto Apply All';
          const preview = document.createElement('div');
          preview.className = 'preview-list';
          preview.style.marginTop = '12px';

          populateArea.appendChild(info);
          populateArea.appendChild(scanBtn);
          populateArea.appendChild(autoBtn);
          populateArea.appendChild(preview);

          pane.appendChild(formArea);
          pane.appendChild(populateArea);
          contents.appendChild(pane);

          // subtabs switching
          stForm.addEventListener('click', () => {
            stForm.classList.add('active');
            stPop.classList.remove('active');
            formArea.style.display = 'block';
            populateArea.style.display = 'none';
          });
          stPop.addEventListener('click', () => {
            stPop.classList.add('active');
            stForm.classList.remove('active');
            formArea.style.display = 'none';
            populateArea.style.display = 'block';
            scanPopulate(i, preview);
          });

          // actions
          scanBtn.addEventListener('click', () => scanPopulate(i, preview));
          autoBtn.addEventListener('click', () => {
            const items = scanPopulate(i, preview);
            const selections = [];
            items.forEach((it) => {
              if (it.candidates && it.candidates.length > 0) {
                const c = it.candidates[0];
                selections.push({ name: it.name, value: c.value });
              }
            });
            applyPreviewSelections(i, selections);
          });
        });

        // Add a dedicated 'Templates' tab where the templates JSON can be edited.
        // Only add when devMode is enabled.
        (function addTemplatesTab() {
          if (!devMode) return;
          const tplIndex = formConfig.length;
          const tplTab = document.createElement('div');
          tplTab.className = 'tab right';
          tplTab.textContent = 'Templates';
          tplTab.dataset.index = tplIndex;
          tplTab.addEventListener('click', () => activateTab(tplIndex));
          tabbar.appendChild(tplTab);

          const tplPane = document.createElement('div');
          tplPane.className = 'tab-pane';
          tplPane.style.display = 'none';
          tplPane.dataset.index = tplIndex;

          const paneContent = document.createElement('div');
          paneContent.className = 'tab-content';
          const label = document.createElement('label');
          label.textContent = 'Templates';
          paneContent.appendChild(label);

          // Inline help explaining how to edit templates
          const help = document.createElement('div');
          help.className = 'meta';
          help.style.marginTop = '8px';
          help.innerHTML =
            '<strong>How to edit templates:</strong> <ul style="margin:6px 0 0 18px;padding:0;">' +
            '<li>Select an existing template or click <em>+ New</em> to create one.</li>' +
            '<li><em>Label</em>: a friendly name shown in selects.</li>' +
            '<li><em>Template config</em>: JSON object (leave blank for full JSON output). Example: <code>{"type":"template","template":"Hello {firstName}"}</code> or <code>{"type":"sprintf","template":"%(firstName)s"}</code>.</li>' +
            '<li><em>Fields</em>: a JSON array of field objects, e.g. <code>[{"label":"Respondent","name":"firstName","type":"text"}, ...]</code>.</li>' +
            '<li>Click <em>Save</em> to apply — left-side forms update immediately and the template is saved to localStorage.</li>' +
            '</ul>';
          paneContent.appendChild(help);

          const tplSelectorRow = document.createElement('div');
          tplSelectorRow.style.display = 'flex';
          tplSelectorRow.style.alignItems = 'center';
          tplSelectorRow.style.gap = '8px';
          tplSelectorRow.style.marginTop = '8px';
          const tplSelect = document.createElement('select');
          tplSelect.style.flex = '1';
          const addBtn = document.createElement('button');
          addBtn.type = 'button';
          addBtn.className = 'btn ghost';
          addBtn.textContent = '+ New';
          tplSelectorRow.appendChild(tplSelect);
          tplSelectorRow.appendChild(addBtn);
          paneContent.appendChild(tplSelectorRow);

          const labelRow = document.createElement('div');
          labelRow.style.marginTop = '8px';
          const lblLabel = document.createElement('label');
          lblLabel.textContent = 'Label';
          const lblInput = document.createElement('input');
          lblInput.type = 'text';
          lblInput.style.width = '100%';
          labelRow.appendChild(lblLabel);
          labelRow.appendChild(lblInput);
          paneContent.appendChild(labelRow);

          const cfgLabel = document.createElement('label');
          cfgLabel.textContent = 'Template config (JSON)';
          cfgLabel.style.marginTop = '8px';
          const cfgTa = document.createElement('textarea');
          cfgTa.rows = 6;
          cfgTa.style.width = '100%';
          paneContent.appendChild(cfgLabel);
          paneContent.appendChild(cfgTa);

          const fieldsLabel = document.createElement('label');
          fieldsLabel.textContent = 'Fields (JSON array)';
          fieldsLabel.style.marginTop = '8px';
          const fieldsTa = document.createElement('textarea');
          fieldsTa.rows = 8;
          fieldsTa.style.width = '100%';
          paneContent.appendChild(fieldsLabel);
          paneContent.appendChild(fieldsTa);

          const saveBtn = document.createElement('button');
          saveBtn.className = 'btn';
          saveBtn.type = 'button';
          saveBtn.textContent = 'Save';
          const loadBtn = document.createElement('button');
          loadBtn.className = 'btn ghost';
          loadBtn.type = 'button';
          loadBtn.textContent = 'Load';
          loadBtn.style.marginLeft = '8px';
          const unloadBtn = document.createElement('button');
          unloadBtn.className = 'btn ghost';
          unloadBtn.type = 'button';
          unloadBtn.textContent = 'Unload';
          unloadBtn.style.marginLeft = '8px';
          const delBtn = document.createElement('button');
          delBtn.className = 'btn ghost';
          delBtn.type = 'button';
          delBtn.textContent = 'Delete';
          delBtn.style.marginLeft = '8px';
          const resetBtn = document.createElement('button');
          resetBtn.className = 'btn ghost';
          resetBtn.type = 'button';
          resetBtn.textContent = 'Reset to defaults';
          resetBtn.style.marginLeft = '8px';
          paneContent.appendChild(saveBtn);
          paneContent.appendChild(loadBtn);
          paneContent.appendChild(unloadBtn);
          paneContent.appendChild(delBtn);
          paneContent.appendChild(resetBtn);

          // helper: populate selector
          function refreshTplSelect() {
            tplSelect.innerHTML = '';
            templates.forEach((t) => {
              const o = document.createElement('option');
              o.value = t.id;
              o.textContent = t.label || t.id;
              tplSelect.appendChild(o);
            });
          }
          refreshTplSelect();

          function loadSelected() {
            const id = tplSelect.value;
            const t = templates.find((x) => x.id === id);
            if (!t) {
              lblInput.value = '';
              cfgTa.value = '';
              fieldsTa.value = '';
              return;
            }
            lblInput.value = t.label || '';
            try {
              cfgTa.value = t.cfg ? JSON.stringify(t.cfg, null, 2) : '';
            } catch (e) {
              cfgTa.value = '';
            }
            try {
              fieldsTa.value = t.fields ? JSON.stringify(t.fields, null, 2) : '';
            } catch (e) {
              fieldsTa.value = '';
            }
          }
          tplSelect.addEventListener('change', loadSelected);
          loadSelected();

          addBtn.addEventListener('click', () => {
            const id = `custom-${Date.now()}`;
            const nt = { id, label: id, cfg: null, fields: [] };
            templates.push(nt);
            // create a corresponding new form tab for this custom template
            try {
              const newForm = {
                title: nt.label || nt.id,
                format: nt.cfg ? JSON.parse(JSON.stringify(nt.cfg)) : null,
                fields: JSON.parse(JSON.stringify(nt.fields || [])),
                _templateId: nt.id,
              };
              formConfig.push(newForm);
              // persist mapping for the newly created tab
              persistTemplateMap();
            } catch (e) {}
            templatesMap = Object.fromEntries(templates.map((x) => [x.id, x]));
            localStorage.setItem('nfg-templates', JSON.stringify(templates));
            refreshTplSelect();
            tplSelect.value = id;
            loadSelected();
            // rebuild so the new form tab appears on the left
            build();
          });

          // Load: create a form tab for the selected template if none exists
          loadBtn.addEventListener('click', () => {
            const id = tplSelect.value;
            if (!id) return;
            try {
              // if a tab already exists for this template, do nothing
              let exists = false;
              for (let j = 0; j < formConfig.length; j++) {
                if (formConfig[j] && formConfig[j]._templateId === id) {
                  exists = true;
                  break;
                }
              }
              if (!exists) {
                const t = templates.find((x) => x.id === id) || templatesMap[id];
                const newForm = {
                  title: (t && t.label) || id,
                  format: t && t.cfg ? JSON.parse(JSON.stringify(t.cfg)) : null,
                  fields: t && t.fields ? JSON.parse(JSON.stringify(t.fields)) : [],
                  _templateId: id,
                };
                formConfig.push(newForm);
                templatesMap = Object.fromEntries(templates.map((x) => [x.id, x]));
                // persist mapping and templates
                try { persistTemplateMap(); } catch (e) {}
                build();
                // activate the newly created tab (last index)
                try { activateTab(formConfig.length - 1); } catch (e) {}
              }
            } catch (e) {}
            // keep templates pane active
            try { activateTab(Number(tplPane.dataset.index)); } catch (e) {}
          });

          // Unload button handled elsewhere in templates pane; per-form Unload exists below when devMode enabled.

          saveBtn.addEventListener('click', () => {
            const id = tplSelect.value;
            const t = templates.find((x) => x.id === id);
            if (!t) return;
            t.label = lblInput.value || t.label || t.id;
            try {
              const parsedCfg = cfgTa.value.trim() ? JSON.parse(cfgTa.value) : null;
              t.cfg = parsedCfg;
            } catch (e) {
              alert('Invalid template config JSON: ' + e.message);
              return;
            }
            try {
              const parsedFields = fieldsTa.value.trim() ? JSON.parse(fieldsTa.value) : [];
              if (!Array.isArray(parsedFields)) throw new Error('Fields must be an array');
              t.fields = parsedFields;
            } catch (e) {
              alert('Invalid fields JSON: ' + e.message);
              return;
            }
            // If this template maps to a default form (tpl-<index>), update that formConfig entry
            try {
              const m = /^tpl-(\d+)$/.exec(t.id);
              if (m) {
                const idx = Number(m[1]);
                if (formConfig[idx]) {
                    // apply fields and cfg to the in-memory formConfig so the tab reflects changes
                    formConfig[idx].fields = JSON.parse(JSON.stringify(t.fields || []));
                    // explicitly set format to null when template cfg is null/blank
                    formConfig[idx].format = t.cfg ? JSON.parse(JSON.stringify(t.cfg)) : null;
                    formConfig[idx]._templateId = t.id;
                  }
              } else {
                // For custom templates, if a corresponding form exists, update it too
                try {
                  for (let j = 0; j < formConfig.length; j++) {
                    if (formConfig[j] && formConfig[j]._templateId === t.id) {
                      formConfig[j].fields = JSON.parse(JSON.stringify(t.fields || []));
                      formConfig[j].format = t.cfg ? JSON.parse(JSON.stringify(t.cfg)) : null;
                      formConfig[j].title = t.label || formConfig[j].title;
                    }
                  }
                } catch (e) {}
              }
            } catch (e) {}
            templatesMap = Object.fromEntries(templates.map((x) => [x.id, x]));
            localStorage.setItem('nfg-templates', JSON.stringify(templates));
            // persist any mapping changes made by save
            try { persistTemplateMap(); } catch (e) {}
            // preserve templates tab and selection after rebuild
            const preserveIndex = tplPane.dataset.index;
            const preserveId = t.id;
            build();
            try {
              activateTab(Number(preserveIndex));
              const newPane = contents.querySelector(`.tab-pane[data-index='${preserveIndex}']`);
              if (newPane) {
                const newSelect = newPane.querySelector('select');
                if (newSelect) {
                  newSelect.value = preserveId;
                  newSelect.dispatchEvent(new Event('change'));
                }
                // status appended after applying to form panes below
              }
            } catch (e) {}
            // Also trigger change on any form panes that currently have this template selected
            try {
              suppressTabActivation = true;
              for (let fi = 0; fi < formConfig.length; fi++) {
                const formPane = contents.querySelector(`.tab-pane[data-index='${fi}']`);
                if (!formPane) continue;
                const formTpl = formPane.querySelector('select');
                if (!formTpl) continue;
                if (formTpl.value === preserveId) {
                  formTpl.dispatchEvent(new Event('change'));
                }
              }
            } catch (e) {}
            finally { suppressTabActivation = false; }
            // re-activate templates tab and show saved status (after form panes updated)
            try {
              activateTab(Number(preserveIndex));
              const tplPane = contents.querySelector(`.tab-pane[data-index='${preserveIndex}']`);
              if (tplPane) {
                const status = document.createElement('div');
                status.className = 'meta';
                status.textContent = 'Saved';
                status.style.marginTop = '8px';
                tplPane.querySelector('.tab-content').appendChild(status);
                setTimeout(() => status.remove(), 1800);
              }
            } catch (e) {}
          });

          delBtn.addEventListener('click', () => {
            const id = tplSelect.value;
            const preserveIndex = tplPane.dataset.index;
            templates = templates.filter((x) => x.id !== id);
            templatesMap = Object.fromEntries(templates.map((x) => [x.id, x]));
            localStorage.setItem('nfg-templates', JSON.stringify(templates));
            // update persisted mapping after deletion
            try { persistTemplateMap(); } catch (e) {}
            refreshTplSelect();
            loadSelected();
            // If this was a custom template that had an associated form tab, remove that tab
            try {
              if (id && id.startsWith('custom-')) {
                for (let j = formConfig.length - 1; j >= 0; j--) {
                  if (formConfig[j] && formConfig[j]._templateId === id) formConfig.splice(j, 1);
                }
              }
            } catch (e) {}
            build();
            // pick first available template in the templates pane (no status yet)
            try {
              activateTab(Number(preserveIndex));
              const newPane = contents.querySelector(`.tab-pane[data-index='${preserveIndex}']`);
              if (newPane) {
                const newSelect = newPane.querySelector('select');
                if (newSelect && newSelect.options.length) newSelect.selectedIndex = 0;
              }
            } catch (e) {}

            // If any form panes used the deleted template, reset them to first option
            try {
              suppressTabActivation = true;
              for (let fi = 0; fi < formConfig.length; fi++) {
                const formPane = contents.querySelector(`.tab-pane[data-index='${fi}']`);
                if (!formPane) continue;
                const formTpl = formPane.querySelector('select');
                if (!formTpl) continue;
                // if the select no longer has the previously selected value, pick first and trigger change
                if (!formTpl.querySelector(`option[value="${id}"]`)) {
                  if (formTpl.options.length) {
                    formTpl.selectedIndex = 0;
                    formTpl.dispatchEvent(new Event('change'));
                  }
                }
              }
            } catch (e) {}
            finally { suppressTabActivation = false; }

            // finally re-activate templates tab and show Deleted status
            try {
              const newTplTab = tabbar.querySelector('.tab.right');
              if (newTplTab) {
                activateTab(Number(newTplTab.dataset.index));
                const finalPane = contents.querySelector(`.tab-pane[data-index='${newTplTab.dataset.index}']`);
                if (finalPane) {
                  const status = document.createElement('div');
                  status.className = 'meta';
                  status.textContent = 'Deleted';
                  status.style.marginTop = '8px';
                  finalPane.querySelector('.tab-content').appendChild(status);
                  setTimeout(() => status.remove(), 1800);
                }
              }
            } catch (e) {}
          });

          resetBtn.addEventListener('click', () => {
            const preserveIndex = tplPane.dataset.index;
            localStorage.removeItem('nfg-templates');
            // remove persisted per-tab template mapping as well
            try { localStorage.removeItem(templateMapKey); templateMap = {}; } catch (e) {}
            templates = defaultTemplates.slice();
            templatesMap = Object.fromEntries(templates.map((x) => [x.id, x]));
            refreshTplSelect();
            loadSelected();
            // restore original formConfig fields/formats for default tabs
            try {
              for (let idx = 0; idx < formConfig.length; idx++) {
                if (originalFormConfig[idx]) {
                  formConfig[idx].fields = JSON.parse(JSON.stringify(originalFormConfig[idx].fields || []));
                  formConfig[idx].format = JSON.parse(JSON.stringify(originalFormConfig[idx].format || null));
                  if (originalFormConfig[idx]._templateId) formConfig[idx]._templateId = originalFormConfig[idx]._templateId;
                }
              }
            } catch (e) {}
            build();
            try {
              const newTplTab = tabbar.querySelector('.tab.right');
              if (newTplTab) {
                activateTab(Number(newTplTab.dataset.index));
                const newPane = contents.querySelector(`.tab-pane[data-index='${newTplTab.dataset.index}']`);
                if (newPane) {
                  const newSelect = newPane.querySelector('select');
                  if (newSelect) {
                    if (newSelect.options.length) newSelect.selectedIndex = 0;
                      newSelect.dispatchEvent(new Event('change'));
                  }
                    // re-query the pane after dispatch in case the DOM was rebuilt
                    const freshPane = contents.querySelector(`.tab-pane[data-index='${newTplTab.dataset.index}']`);
                    const targetPane = freshPane || newPane;
                    // Do not append status here — the DOM may be rebuilt by subsequent
                    // programmatic change events. Status will be appended after all
                    // programmatic updates complete.
                }
              }
            } catch (e) {}
            // After reset, ensure form panes point to a valid template and trigger change
            try {
              suppressTabActivation = true;
              for (let fi = 0; fi < formConfig.length; fi++) {
                const formPane = contents.querySelector(`.tab-pane[data-index='${fi}']`);
                if (!formPane) continue;
                const formTpl = formPane.querySelector('select');
                if (!formTpl) continue;
                // if the currently selected option is no longer present, select first
                if (!formTpl.querySelector(`option[value="${formTpl.value}"]`)) {
                  if (formTpl.options.length) {
                    formTpl.selectedIndex = 0;
                    formTpl.dispatchEvent(new Event('change'));
                  }
                }
              }
            } catch (e) {}
            finally { suppressTabActivation = false; }
            // Ensure Templates tab remains active after programmatic changes
            try {
              const newTplTab = tabbar.querySelector('.tab.right');
              if (newTplTab) {
                activateTab(Number(newTplTab.dataset.index));
                // append status after final activation so it isn't removed by rebuild
                try {
                  const finalPane = contents.querySelector(`.tab-pane[data-index='${newTplTab.dataset.index}']`);
                  if (finalPane) {
                    const status = document.createElement('div');
                    status.className = 'meta';
                    status.textContent = 'Reset to defaults';
                    status.style.marginTop = '8px';
                    const container = finalPane.querySelector('.tab-content');
                    if (container) container.appendChild(status);
                    setTimeout(() => status.remove(), 1800);
                  }
                } catch (e) {}
              }
            } catch (e) {}
          });

          tplPane.appendChild(paneContent);
          contents.appendChild(tplPane);
        })();

        activateTab(0);
      }

      function activateTab(index) {
        Array.from(tabbar.children).forEach((t) =>
          t.classList.toggle('active', Number(t.dataset.index) === index)
        );
        Array.from(contents.children).forEach(
          (p) => (p.style.display = Number(p.dataset.index) === index ? '' : 'none')
        );
      }

      // Scans other tabs for values matching field names in target tab.
      // Returns array of items {name, value, fromTabIndex, fromTabTitle, found}
      function scanPopulate(targetIndex, previewContainer) {
        const targetPane = contents.querySelector(`.tab-pane[data-index='${targetIndex}']`);
        const targetForm = targetPane.querySelector('form.generated-form');
        const targetNames = Array.from(targetForm.elements)
          .map((e) => e.name)
          .filter(Boolean)
          .filter((n) => !n.endsWith('_key') && !n.endsWith('_combined'));
        const items = targetNames.map((n) => ({ name: n, candidates: [] }));

        formConfig.forEach((tab, ti) => {
          if (ti === targetIndex) return;
          const pane = contents.querySelector(`.tab-pane[data-index='${ti}']`);
          if (!pane) return;
          const form = pane.querySelector('form.generated-form');
          if (!form) return;
          targetNames.forEach((name, idx) => {
            const els = Array.from(form.querySelectorAll(`[name="${CSS.escape(name)}"]`));
            if (!els || els.length === 0) return;
            // collect candidate(s) from this tab
            if (els[0].type === 'radio') {
              const checked = els.find((e) => e.checked);
              if (checked)
                items[idx].candidates.push({
                  value: checked.value || '',
                  fromTab: ti,
                  fromTitle: tab.title,
                });
            } else if (els[0].type === 'checkbox') {
              const checked = els.find((e) => e.checked);
              if (checked)
                items[idx].candidates.push({
                  value: checked.value || 'on',
                  fromTab: ti,
                  fromTitle: tab.title,
                });
            } else {
              for (const e of els) {
                if (e.value !== undefined && String(e.value).trim() !== '') {
                  items[idx].candidates.push({ value: e.value, fromTab: ti, fromTitle: tab.title });
                  break;
                }
              }
            }
          });
        });

        // render preview with multiple candidate choices per field
        previewContainer.innerHTML = '';
        items.forEach((it) => {
          const row = document.createElement('div');
          row.className = 'preview-item';
          const label = document.createElement('div');
          label.style.flex = '1';
          const name = document.createElement('div');
          name.className = 'small';
          name.textContent = it.name;
          label.appendChild(name);

          if (it.candidates.length === 0) {
            const none = document.createElement('div');
            none.className = 'meta';
            none.textContent = 'no value found';
            label.appendChild(none);
          } else {
            const list = document.createElement('div');
            // add keep-current option first (default) and show the current value
            const keepOpt = document.createElement('div');
            keepOpt.style.display = 'flex';
            keepOpt.style.alignItems = 'center';
            keepOpt.style.gap = '8px';
            keepOpt.style.padding = '2px 0';
            const keepRadio = document.createElement('input');
            keepRadio.type = 'radio';
            keepRadio.name = `choose-${targetIndex}-${it.name}`;
            keepRadio.value = '__keep__';
            keepRadio.checked = true;
            // determine current value from the target form
            let currentVal = '';
            try {
              const currentEls = Array.from(
                targetForm.querySelectorAll(`[name="${CSS.escape(it.name)}"]`)
              );
              if (currentEls && currentEls.length) {
                if (currentEls[0].type === 'radio') {
                  const c = currentEls.find((e) => e.checked);
                  if (c) currentVal = c.value || '';
                } else if (currentEls[0].type === 'checkbox') {
                  const c = currentEls.find((e) => e.checked);
                  if (c) currentVal = c.value || 'on';
                } else {
                  currentVal = currentEls[0].value || '';
                }
              }
            } catch (e) {
              currentVal = '';
            }
            const keepTxt = document.createElement('div');
            keepTxt.className = 'meta';
            keepTxt.textContent = `${currentVal || ''} (Keep current)`;
            keepOpt.appendChild(keepRadio);
            keepOpt.appendChild(keepTxt);
            list.appendChild(keepOpt);

            it.candidates.forEach((c, ci) => {
              const opt = document.createElement('div');
              opt.style.display = 'flex';
              opt.style.alignItems = 'center';
              opt.style.gap = '8px';
              opt.style.padding = '2px 0';
              const r = document.createElement('input');
              r.type = 'radio';
              r.name = `choose-${targetIndex}-${it.name}`;
              r.value = String(ci);
              const txt = document.createElement('div');
              txt.className = 'meta';
              txt.textContent = `${c.value} (from ${c.fromTitle})`;
              opt.appendChild(r);
              opt.appendChild(txt);
              list.appendChild(opt);
            });
            label.appendChild(list);
          }

          row.appendChild(label);
          previewContainer.appendChild(row);
          it._candidates = it.candidates; // store for later
        });

        // Apply selected button
        const applyBtn = document.createElement('button');
        applyBtn.className = 'btn';
        applyBtn.type = 'button';
        applyBtn.textContent = 'Apply Selected';
        applyBtn.style.marginTop = '8px';
        applyBtn.addEventListener('click', () => {
          const selections = [];
          items.forEach((it) => {
            const radios = previewContainer.querySelectorAll(
              `input[name="choose-${targetIndex}-${it.name}"]`
            );
            if (!radios || radios.length === 0) return;
            const checked = Array.from(radios).find((r) => r.checked);
            if (!checked) return;
            const ci = Number(checked.value);
            const cand = it._candidates && it._candidates[ci];
            if (cand) selections.push({ name: it.name, value: cand.value });
          });
          applyPreviewSelections(targetIndex, selections);
        });
        previewContainer.appendChild(applyBtn);

        return items;
      }

      // Generate output based on format configuration and values object
      function generateOutput(formatCfg, values) {
        if (!formatCfg) return JSON.stringify(values, null, 2);
        const tpl = formatCfg.template || '';
        if (formatCfg.type === 'template') {
          return tpl.replace(/\{([^}]+)\}/g, (_, name) => {
            // prefer explicit value (even empty string) if provided; only
            // fall back to combined input when the explicit key is absent
            const hasExplicit = values && Object.prototype.hasOwnProperty.call(values, name);
            let val = hasExplicit ? values[name] : undefined;
            if (!hasExplicit && values && Object.prototype.hasOwnProperty.call(values, name + '_combined')) {
              val = values[name + '_combined'];
            }

            // If an explicit value exists, return it without reformatting.
            if (hasExplicit) {
              if (Array.isArray(val)) {
                // preserve array contents exactly (no numbering), join with newlines
                return val.join('\n');
              }
              return val !== undefined && val !== null ? String(val) : '';
            }

            // If the value is an array, strip any existing numeric prefixes
            // (e.g. "1. A") then format as a numbered list
            if (Array.isArray(val)) {
              if (val.length === 0) return '';
              const cleaned = val.map((v) =>
                String(v).replace(/^\s*(?:\d+[\.)]\s*)?(?:[-*•]\s*)?/, '').trim()
              );
              return '\n' + cleaned.map((v, i) => ` ${i + 1}. ${v}`).join('\n');
            }

            // If it's a string containing separators like '>', split and format
            if (typeof val === 'string' && val.includes('>')) {
              const parts = val
                .split('>')
                .map((s) => s.trim())
                .filter(Boolean)
                .map((p) => String(p).replace(/^\s*(?:\d+[\.)]\s*)?(?:[-*•]\s*)?/, '').trim());
              if (parts.length === 0) return '';
              return '\n' + parts.map((p, i) => ` ${i + 1}. ${p}`).join('\n');
            }

            // fallback: string/number or empty
            return val !== undefined && val !== null ? String(val) : '';
          });
        }
        if (formatCfg.type === 'sprintf') {
          // support Python-style named tokens: %(name)s
          return tpl.replace(/%\(([^)]+)\)s/g, (_, name) =>
            values[name] !== undefined ? values[name] : ''
          );
        }
        // fallback: if formatCfg is string treat as template
        if (typeof formatCfg === 'string') {
          return formatCfg.replace(/\{([^}]+)\}/g, (_, name) =>
            values[name] !== undefined ? values[name] : ''
          );
        }
        return JSON.stringify(values, null, 2);
      }

      function applyPreviewSelections(targetIndex, selections) {
        const targetPane = contents.querySelector(`.tab-pane[data-index='${targetIndex}']`);
        const targetForm = targetPane.querySelector('form.generated-form');
        selections.forEach((sel) => {
          // resolve field config for this target tab + field name
          const fieldCfg =
            formConfig[targetIndex] && formConfig[targetIndex].fields
              ? formConfig[targetIndex].fields.find((f) => f.name === sel.name)
              : null;
          // If this field's type is 'steps' and there are no inputs yet, create items
          if (fieldCfg && fieldCfg.type === 'steps') {
            const parts = String(sel.value || '')
              .split('>')
              .map((s) => s.trim())
              .filter(Boolean);
            const existing = Array.from(
              targetForm.querySelectorAll(`[name="${CSS.escape(sel.name)}"]`)
            );
            const container = targetForm.querySelector(`.steps-container[data-name="${sel.name}"]`);
            const list = container && container.querySelector('.steps-list');
            if (parts.length > 1) {
              // clear existing list
              if (list) list.innerHTML = '';
              // create inputs per part
              parts.forEach((p) => {
                if (list) {
                  if (p.includes('=>')) {
                    const [k, ...rest] = p.split('=>');
                    const val = rest.join('=>').trim();
                    createStepRow(sel.name, { key: k.trim(), val }, container, list);
                  } else {
                    createStepRow(sel.name, p, container, list);
                  }
                }
              });
            }
          }

          const els = Array.from(targetForm.querySelectorAll(`[name="${CSS.escape(sel.name)}"]`));
          if (!els || els.length === 0) return;
          // radios
          if (els[0].type === 'radio') {
            els.forEach((r) => {
              r.checked = r.value == sel.value;
            });
            return;
          }
          // checkboxes
          if (els[0].type === 'checkbox') {
            els.forEach((c) => {
              c.checked = !!sel.value && String(sel.value) !== 'false' && String(sel.value) !== '0';
            });
            return;
          }
          // For steps fields, if sel.value contains '>' distribute values
          if (fieldCfg && fieldCfg.type === 'steps' && String(sel.value || '').includes('>')) {
            const parts = String(sel.value || '')
              .split('>')
              .map((s) => s.trim())
              .filter(Boolean);
            // ensure we have enough inputs
            if (parts.length > els.length) {
              const container = targetForm.querySelector(
                `.steps-container[data-name="${sel.name}"]`
              );
              const list = container && container.querySelector('.steps-list');
              for (let i = els.length; i < parts.length; i++) {
                if (list) createStepRow(sel.name, '', container, list);
              }
            }
            const newEls = Array.from(
              targetForm.querySelectorAll(`[name="${CSS.escape(sel.name)}"]`)
            );
            const newKeys = Array.from(
              targetForm.querySelectorAll(`[name="${CSS.escape(sel.name + '_key')}"]`)
            );
            parts.forEach((p, idx) => {
              let key = '';
              let val = p;
              if (p.includes('=>')) {
                const [k, ...rest] = p.split('=>');
                key = k.trim();
                val = rest.join('=>').trim();
              }
              if (newEls[idx]) newEls[idx].value = val;
              if (newKeys[idx]) {
                if (key) newKeys[idx].value = key;
                else if (container && container.dataset) {
                  if (container.dataset.keyMode === 'numbered')
                    newKeys[idx].value = String(idx + 1);
                  else if (container.dataset.keyMode === 'bullet') newKeys[idx].value = '-';
                }
              }
            });
            return;
          }

          // text/select/textarea - set first element's value
          const e = els[0];
          try {
            e.value = sel.value;
          } catch (e) {}
        });
      }

      // initial build
      build();

      // Theme handling: toggle dark mode and persist choice
      (function () {
        const key = 'nfg-theme';
        const btn = document.getElementById('themeToggle');
        function applyTheme(t) {
          if (t === 'dark') document.documentElement.classList.add('dark');
          else document.documentElement.classList.remove('dark');
          if (btn) btn.textContent = t === 'dark' ? 'Light' : 'Dark';
        }
        const saved =
          localStorage.getItem(key) ||
          (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
            ? 'dark'
            : 'light');
        applyTheme(saved);
        if (btn)
          btn.addEventListener('click', () => {
            const isDark = document.documentElement.classList.toggle('dark');
            const next = isDark ? 'dark' : 'light';
            localStorage.setItem(key, next);
            if (btn) btn.textContent = isDark ? 'Light' : 'Dark';
          });
      })();
    </script>
  </body>
</html>

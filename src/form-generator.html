<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Note Form Generator</title>
    <style>
      :root {
        --bg: #f7f9fc;
        --card: #ffffff;
        --text: #111216;
        --accent: #2b8cff;
        --muted: #666666;
        --border: #e9eef6;
        --panel: #fbfdff;
      }
      .dark {
        --bg: #0b1220;
        --card: #0f1724;
        --text: #e6eef8;
        --accent: #4aa3ff;
        --muted: #94a9c2;
        --border: #253244;
        --panel: #071226;
      }
      body {
        font-family: Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        margin: 0;
        background: var(--bg);
        color: var(--text);
        transition: background 0.18s, color 0.18s;
      }
      .container {
        max-width: 960px;
        margin: 28px auto;
        padding: 18px;
        background: var(--card);
        border-radius: 8px;
        box-shadow: 0 6px 18px rgba(2, 6, 23, 0.06);
      }
      .top {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .top {
        /* keep the header stable and prevent reflow when tabs change */
        position: sticky;
        top: 0;
        z-index: 3;
        padding-bottom: 8px;
      }
      .top h1 {
        flex: 0 0 auto;
      }
      .top-controls {
        display: flex;
        align-items: center;
        gap: 10px;
        flex: 0 0 auto;
        white-space: nowrap;
      }
      h1 {
        font-size: 18px;
        margin: 0;
      }
      .tabs {
        display: flex;
        gap: 6px;
        margin-top: 14px;
        border-bottom: 1px solid var(--border);
        overflow-x: auto;
        white-space: nowrap;
        -webkit-overflow-scrolling: touch;
      }
      .tab {
        padding: 10px 14px;
        cursor: pointer;
        border-radius: 6px 6px 0 0;
        color: var(--muted);
        flex: 0 0 auto;
      }
      .tab.right {
        margin-left: auto;
      }
      .tab.active {
        background: linear-gradient(180deg, #fff, #f4f8ff);
        color: var(--accent);
        box-shadow: 0 -4px 12px rgba(43, 140, 255, 0.06);
        border-bottom: 2px solid #fff;
      }
      .tab-content {
        padding: 18px;
      }
      .field {
        margin-bottom: 12px;
      }
      label {
        display: block;
        margin-bottom: 6px;
        font-weight: 600;
      }
      input[type='text'],
      input[type='number'],
      select,
      textarea {
        width: 100%;
        padding: 8px 10px;
        border: 1px solid var(--border);
        border-radius: 6px;
        background: transparent;
        color: var(--text);
      }
      .subtabs {
        display: flex;
        gap: 6px;
        margin-bottom: 12px;
      }
      .subtab {
        padding: 6px 10px;
        border-radius: 6px;
        background: transparent;
        border: 1px solid var(--border);
        cursor: pointer;
        color: var(--muted);
      }
      .subtab.active {
        background: var(--accent);
        color: #fff;
      }
      .btn {
        display: inline-block;
        padding: 8px 12px;
        border-radius: 6px;
        background: var(--accent);
        color: #fff;
        border: 0;
        cursor: pointer;
      }
      .btn.warn {
        background: #e05252;
        color: #fff;
        border: 0;
      }
      .btn.ghost {
        background: #f2f6ff;
        color: var(--accent);
        border: 1px solid #d7e7ff;
      }
      .btn-warn {
        background: #e05252;
        color: #fff;
        border: 0;
      }
      .btn-warn.ghost {
        background: #fff5f5;
        color: #e05252;
        border: 1px solid #ffd6d6;
      }
      .meta {
        color: var(--muted);
        font-size: 13px;
      }
      .preview-list {
        border: 1px solid var(--border);
        padding: 10px;
        border-radius: 6px;
        background: var(--panel);
      }
      .field-header {
        margin: 8px 0;
        font-weight: 700;
        color: var(--text);
      }
      .preview-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 0;
        border-bottom: 1px dashed #f0f4fb;
      }
      .preview-item:last-child {
        border-bottom: none;
      }
      .field-inline {
        display: inline-block;
        vertical-align: top;
        margin-right: 4%;
        box-sizing: border-box;
        max-width: 100%;
      }
      .small {
        font-size: 13px;
        color: #333;
      }
      /* Dev toggle switch */
      .switch {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        margin-left: 6px;
      }
      .switch input {
        display: none;
      }
      .switch .knob {
        width: 40px;
        height: 20px;
        background: #d7dbe0;
        border-radius: 20px;
        position: relative;
        transition: background 0.15s;
        box-shadow: inset 0 -2px 0 rgba(0, 0, 0, 0.03);
      }
      .switch .knob::after {
        content: '';
        position: absolute;
        left: 3px;
        top: 3px;
        width: 14px;
        height: 14px;
        background: #fff;
        border-radius: 50%;
        transition: left 0.15s;
        box-shadow: 0 1px 2px rgba(2, 6, 23, 0.08);
      }
      .switch input:checked + .knob {
        background: var(--accent);
      }
      .switch input:checked + .knob::after {
        left: 23px;
      }
      .switch .label {
        font-size: 13px;
        color: var(--muted);
        user-select: none;
      }
      .footer {
        margin-top: 12px;
        border-top: 1px solid var(--border);
        padding-top: 10px;
        text-align: center;
        font-size: 13px;
        color: var(--muted);
      }
      .footer-inner {
        max-width: 960px;
        margin: 0 auto;
        padding: 0 18px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="top">
        <h1>Note Form Generator</h1>
        <div class="top-controls">
          <button id="themeToggle" class="btn ghost" type="button" aria-label="Toggle dark mode">
            Dark
          </button>
        </div>
      </div>

      <div id="tabbar" class="tabs"></div>
      <div id="contents"></div>
    </div>
    <footer class="footer">
      <div class="footer-inner">
        <div class="meta">Copyright ©️ 2026 Valithor Obsidion &lt;valithor@discordphp.org&gt;</div>
      </div>
    </footer>

    <script>
      const formConfig =
        window.formConfig && Array.isArray(window.formConfig) ? window.formConfig : [];

      // Keep a pristine copy of the original formConfig so we can restore defaults
      const originalFormConfig = JSON.parse(JSON.stringify(formConfig));

      const tabbar = document.getElementById('tabbar');
      const contents = document.getElementById('contents');

      // Dev mode toggle: when true, Templates pane and per-form Unload buttons are visible.
      // Persisted in localStorage key 'nfg-dev-mode'. Default is false to preserve current behavior.
      const devKey = 'nfg-dev-mode';
      let devMode = false;
      try {
        const s = localStorage.getItem(devKey);
        if (s !== null) devMode = s === 'true';
      } catch (e) {}

      // create a small Dev toggle switch next to theme toggle
      (function addDevToggleBtn() {
        try {
          const header = document.querySelector('.top > div');
          if (!header) return;
          const wrapper = document.createElement('label');
          wrapper.className = 'switch';
          wrapper.dataset.devToggle = 'true';
          wrapper.style.marginLeft = '6px';
          // inner structure: checkbox + knob + label
          wrapper.innerHTML = `<input id="devToggle" type="checkbox" ${
            devMode ? 'checked' : ''
          }><span class="knob"></span><span class="label">${devMode ? 'Dev On' : 'Dev Off'}</span>`;
          const checkbox = wrapper.querySelector('input');
          if (checkbox) checkbox.autocomplete = 'off';
          const textLabel = wrapper.querySelector('.label');
          // export button (visible only in dev mode)
          const exportBtn = document.createElement('button');
          exportBtn.type = 'button';
          exportBtn.className = 'btn ghost';
          exportBtn.textContent = 'Export HTML';
          exportBtn.style.marginLeft = '8px';
          exportBtn.style.display = devMode ? '' : 'none';
          exportBtn.dataset.exportButton = 'true';
          exportBtn.addEventListener('click', async () => {
            try {
              const seed = [];
              // Safely serialize JSON for embedding inside a <script> tag.
              // Replace literal '<' and line terminators that could break
              // the script or close the script tag early.
              const safeJson = (obj) => {
                try {
                  return JSON.stringify(obj)
                    .replace(/</g, '\\u003c')
                    .replace(/\u2028/g, '\\u2028')
                    .replace(/\u2029/g, '\\u2029');
                } catch (e) {
                  return 'null';
                }
              };
              try {
                seed.push('window.formConfig = ' + safeJson(formConfig) + ';');
              } catch (e) {}
              try {
                seed.push("localStorage.setItem('nfg-forms', " + safeJson(forms) + ');');
              } catch (e) {}
              try {
                seed.push("localStorage.setItem('nfg-outputs', " + safeJson(outputs) + ');');
              } catch (e) {}
              try {
                // Compute current mapping from formConfig -> template id so the
                // exported HTML reflects the currently loaded form per-tab even
                // if the mapping wasn't previously persisted.
                const exportMap = {};
                try {
                  for (let ei = 0; ei < formConfig.length; ei++) {
                    const tid = formConfig[ei] && formConfig[ei]._templateId;
                    if (tid && formsMap && formsMap[tid]) exportMap[ei] = tid;
                  }
                } catch (e) {}
                seed.push("localStorage.setItem('nfg-form-map', " + safeJson(exportMap) + ');');
              } catch (e) {}
              try {
                seed.push("localStorage.setItem('nfg-dev-mode', 'false');");
              } catch (e) {}
              const seedScript = `<script>try{${seed.join('')} }catch(e){}<\/script>`;
              // create a cleaned clone of the document and remove dev UI elements
              const docClone = document.documentElement.cloneNode(true);
              try {
                const toRemove = docClone.querySelectorAll(
                  '[data-dev-toggle], [data-export-button]'
                );
                toRemove.forEach((n) => n.remove());
              } catch (e) {}
              let html = '<!doctype html>\n' + docClone.outerHTML;
              html = html.replace(/<body([^>]*)>/i, (m, attrs) => `<body${attrs}>${seedScript}`);
              // Ask user whether to copy to clipboard or save file. If clipboard
              // isn't available, fall back to saving file.
              let wantCopy = false;
              try {
                if (typeof window.confirm === 'function') {
                  wantCopy = window.confirm(
                    'Copy exported HTML to clipboard? Press OK to copy, Cancel to save to a file.'
                  );
                }
              } catch (e) {
                wantCopy = false;
              }

              if (wantCopy && navigator.clipboard && navigator.clipboard.writeText) {
                try {
                  await navigator.clipboard.writeText(html);
                  alert('Exported HTML copied to clipboard');
                } catch (e) {
                  // fallback to saving file if clipboard fails
                  const blob = new Blob([html], { type: 'text/html' });
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement('a');
                  a.href = url;
                  a.download = 'nfg-export.html';
                  document.body.appendChild(a);
                  a.click();
                  a.remove();
                  setTimeout(() => URL.revokeObjectURL(url), 5000);
                }
              } else {
                const blob = new Blob([html], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'nfg-export.html';
                document.body.appendChild(a);
                a.click();
                a.remove();
                setTimeout(() => URL.revokeObjectURL(url), 5000);
              }
            } catch (err) {
              alert('Export failed: ' + (err && err.message));
            }
          });
          function apply() {
            try {
              localStorage.setItem(devKey, devMode ? 'true' : 'false');
            } catch (e) {}
            if (checkbox) checkbox.checked = devMode;
            if (textLabel) textLabel.textContent = 'Dev';
            if (exportBtn) exportBtn.style.display = devMode ? '' : 'none';
            // Preserve all current form values across the rebuild so toggling
            // dev mode doesn't clear user input.
            const allPrev = {};
            try {
              Array.from(contents.querySelectorAll('.tab-pane')).forEach((pane) => {
                const idx = pane.dataset.index;
                const form = pane.querySelector('form.generated-form');
                if (!form) return;
                const map = {};
                Array.from(form.elements).forEach((e) => {
                  if (!e.name) return;
                  const name = e.name;
                  const val = e.type === 'checkbox' ? (e.checked ? e.value || 'on' : '') : e.value;
                  if (Object.prototype.hasOwnProperty.call(map, name)) {
                    if (!Array.isArray(map[name])) map[name] = [map[name]];
                    map[name].push(val);
                  } else {
                    map[name] = val;
                  }
                });
                allPrev[idx] = map;
              });
            } catch (e) {}
            try {
              build();
            } catch (e) {}
            try {
              Object.keys(allPrev).forEach((idx) => {
                const pane = contents.querySelector(`.tab-pane[data-index='${idx}']`);
                if (!pane) return;
                const form = pane.querySelector('form.generated-form');
                if (!form) return;
                const prev = allPrev[idx] || {};
                Object.keys(prev).forEach((name) => {
                  try {
                    const els = Array.from(form.querySelectorAll(`[name="${CSS.escape(name)}"]`));
                    if (!els || els.length === 0) return;
                    const pv = prev[name];
                    if (els[0].type === 'radio') {
                      els.forEach((r) => (r.checked = r.value == pv));
                      return;
                    }
                    if (els[0].type === 'checkbox') {
                      els.forEach((c) => {
                        if (Array.isArray(pv)) c.checked = pv.includes(c.value);
                        else c.checked = !!pv && String(pv) !== 'false' && String(pv) !== '0';
                      });
                      return;
                    }
                    if (Array.isArray(pv)) {
                      for (let k = 0; k < els.length && k < pv.length; k++) els[k].value = pv[k];
                    } else {
                      els[0].value = pv;
                    }
                  } catch (e) {}
                });
              });
            } catch (e) {}
          }
          checkbox.addEventListener('change', () => {
            devMode = !!checkbox.checked;
            apply();
          });
          // Place the Export button to the left of the theme toggle so enabling
          // dev mode doesn't drastically shift layout. Insert before the
          // `#themeToggle` button when present, otherwise append.
          const themeBtnEl = header.querySelector('#themeToggle');
          if (themeBtnEl) header.insertBefore(exportBtn, themeBtnEl);
          else header.appendChild(exportBtn);
          // Keep the dev toggle after the theme button (end of controls)
          header.appendChild(wrapper);
          apply();
        } catch (e) {}
      })();

      // Build list of available templates (include JSON fallback)
      const defaultTemplates = [{ id: '__json__', label: '__json__', cfg: null }];
      // Create a default template entry for every tab so each tab has a template option
      formConfig.forEach((t, idx) => {
        const id = `tpl-${idx}`;
        const label = t.format && t.format.label ? t.format.label : `${t.title}`;
        const cfg = t.format ? t.format : null;
        defaultTemplates.push({ id, label, cfg });
        // keep a reference on the config so we can detect default when using defaults
        t._templateId = id;
      });

      // Load editable forms from localStorage if present, otherwise merge with defaults
      let forms;
      try {
        const saved = localStorage.getItem('nfg-forms');
        if (saved) {
          const parsed = JSON.parse(saved);
          if (Array.isArray(parsed)) {
            // Start from defaults and overlay saved entries (saved entries override defaults)
            const map = Object.fromEntries(defaultTemplates.map((t) => [t.id, t]));
            for (const s of parsed) {
              if (s && s.id) map[s.id] = s;
            }
            forms = Object.values(map);
          }
        }
      } catch (e) {}
      if (!forms) forms = defaultTemplates.slice();

      // map for quick lookup
      let formsMap = Object.fromEntries(forms.map((x) => [x.id, x]));
      // Outputs: separate persisted output definitions (format + fields)
      const outputsKey = 'nfg-outputs';
      let outputs;
      try {
        const savedOut = localStorage.getItem(outputsKey);
        if (savedOut) {
          const parsed = JSON.parse(savedOut);
          if (Array.isArray(parsed)) outputs = parsed;
        }
      } catch (e) {}
      // if no persisted outputs, derive defaults from formConfig
      if (!outputs) {
        outputs = [];
        for (let i = 0; i < formConfig.length; i++) {
          const f = formConfig[i];
          outputs.push({
            id: `out-${i}`,
            label: f.title || `Output ${i}`,
            cfg: f.format ? JSON.parse(JSON.stringify(f.format)) : null,
            fields: f.fields ? JSON.parse(JSON.stringify(f.fields)) : [],
          });
        }
      }
      let outputsMap = Object.fromEntries(outputs.map((x) => [x.id, x]));
      // key for persisting per-tab form selection (map index -> formId)
      const formMapKey = 'nfg-form-map';
      let formMap = {};
      // try to load saved mapping and apply to formConfig
      try {
        const savedMap = localStorage.getItem(formMapKey);
        if (savedMap) {
          const parsed = JSON.parse(savedMap);
          if (parsed && typeof parsed === 'object') {
            formMap = parsed;
            Object.keys(parsed).forEach((k) => {
              const idx = Number(k);
              const id = parsed[k];
              if (!Number.isNaN(idx) && formConfig[idx] && formsMap[id]) {
                formConfig[idx]._templateId = id;
              }
            });
          }
        }
      } catch (e) {}

      function persistFormMap() {
        try {
          const map = {};
          for (let i = 0; i < formConfig.length; i++) {
            if (formConfig[i] && formConfig[i]._templateId && formsMap[formConfig[i]._templateId]) {
              map[i] = formConfig[i]._templateId;
            }
          }
          formMap = map;
          localStorage.setItem(formMapKey, JSON.stringify(map));
        } catch (e) {}
      }
      // Capture all current form values across tabs. Returns an object
      // mapping pane dataset.index -> { name: value | [values] }
      function captureAllFormValues() {
        const allPrev = {};
        try {
          Array.from(contents.querySelectorAll('.tab-pane')).forEach((pane) => {
            const idx = pane.dataset.index;
            const form = pane.querySelector('form.generated-form');
            if (!form) return;
            const map = {};
            Array.from(form.elements).forEach((e) => {
              if (!e.name) return;
              const name = e.name;
              const val = e.type === 'checkbox' ? (e.checked ? e.value || 'on' : '') : e.value;
              if (Object.prototype.hasOwnProperty.call(map, name)) {
                if (!Array.isArray(map[name])) map[name] = [map[name]];
                map[name].push(val);
              } else {
                map[name] = val;
              }
            });
            allPrev[idx] = map;
          });
        } catch (e) {}
        return allPrev;
      }

      // Restore values captured by `captureAllFormValues` into the rebuilt DOM.
      function restoreAllFormValues(allPrev) {
        try {
          Object.keys(allPrev || {}).forEach((nameIdx) => {
            const pane = contents.querySelector(`.tab-pane[data-index='${nameIdx}']`);
            if (!pane) return;
            const form = pane.querySelector('form.generated-form');
            if (!form) return;
            const prev = allPrev[nameIdx] || {};
            Object.keys(prev).forEach((nm) => {
              try {
                const els = Array.from(form.querySelectorAll(`[name="${CSS.escape(nm)}"]`));
                if (!els || els.length === 0) return;
                const pv = prev[nm];
                if (els[0].type === 'radio') {
                  els.forEach((r) => (r.checked = r.value == pv));
                  return;
                }
                if (els[0].type === 'checkbox') {
                  els.forEach((c) => {
                    if (Array.isArray(pv)) c.checked = pv.includes(c.value);
                    else c.checked = !!pv && String(pv) !== 'false' && String(pv) !== '0';
                  });
                  return;
                }
                if (Array.isArray(pv)) {
                  for (let k = 0; k < els.length && k < pv.length; k++) els[k].value = pv[k];
                } else {
                  els[0].value = pv;
                  // If this is the combined steps input (name ends with '_combined'),
                  // parse it into individual step rows so programmatic population
                  // restores the per-step UI as well.
                  try {
                    if (
                      typeof nm === 'string' &&
                      nm.endsWith('_combined') &&
                      typeof pv === 'string' &&
                      pv.trim()
                    ) {
                      const base = nm.slice(0, -9); // remove trailing '_combined'
                      const parseBtn = els[0].nextElementSibling;
                      // If a Parse button exists adjacent to the combined input, click it.
                      if (parseBtn && parseBtn.textContent && /Parse/.test(parseBtn.textContent)) {
                        parseBtn.click();
                      } else {
                        // Fallback: manually populate the steps list using same logic
                        const container = form.querySelector(
                          `.steps-container[data-name="${base}"]`
                        );
                        const list = container && container.querySelector('.steps-list');
                        if (list) {
                          const parts = pv
                            .split('>')
                            .map((s) => s.trim())
                            .filter(Boolean);
                          list.innerHTML = '';
                          parts.forEach((p) => {
                            if (p.includes('=>')) {
                              const [k, ...rest] = p.split('=>');
                              const val = rest.join('=>').trim();
                              createStepRow(base, { key: k.trim(), val }, container, list);
                            } else {
                              createStepRow(base, p, container, list);
                            }
                          });
                        }
                      }
                    }
                  } catch (e) {}
                }
              } catch (e) {}
            });
          });
        } catch (e) {}
      }
      // counter used to give generated dynamic inputs unique ids
      let dynamicIdCounter = 0;
      // when true, tpl select change handlers should not activate tabs (used during programmatic updates)
      let suppressTabActivation = false;

      // Auto-resize a textarea to fit its content
      function autosizeTextarea(ta) {
        if (!ta) return;
        try {
          ta.style.height = 'auto';
          ta.style.overflow = 'hidden';
          var newH = ta.scrollHeight;
          // Ensure at least one line of height (use computed line-height or font-size as fallback)
          try {
            var cs = window.getComputedStyle(ta);
            var lh = parseFloat(cs.lineHeight) || parseFloat(cs.fontSize) || 16;
            var padTop = parseFloat(cs.paddingTop) || 0;
            var padBottom = parseFloat(cs.paddingBottom) || 0;
            var minH = Math.ceil(lh + padTop + padBottom);
            if (!newH || newH < minH) newH = minH;
          } catch (e) {}
          ta.style.height = newH + 'px';
        } catch (e) {}
      }

      // Highlight the character position reported by a JSON parse error inside a textarea
      function highlightJsonError(ta, err) {
        if (!ta || !err) return;
        try {
          const msg = String(err && err.message ? err.message : '');
          // Look for common position indicators from JSON.parse errors
          const m = msg.match(/at position\s*(\d+)/i) || msg.match(/position\s*(\d+)/i) || msg.match(/column\s*(\d+)/i);
          if (!m) return;
          const pos = Number(m[1]);
          if (Number.isNaN(pos)) return;
          // Focus and select the offending character
          try {
            ta.focus();
            if (typeof ta.setSelectionRange === 'function') {
              // clamp pos to bounds
              const idx = Math.max(0, Math.min(pos, (ta.value || '').length - 1));
              ta.setSelectionRange(idx, idx + 1);
            }
            // Try to scroll the line into view roughly using line-height
            try {
              const cs = window.getComputedStyle(ta);
              const lh = parseFloat(cs.lineHeight) || parseFloat(cs.fontSize) || 16;
              const before = (ta.value || '').slice(0, pos);
              const lineNo = (before.match(/\n/g) || []).length;
              ta.scrollTop = Math.max(0, lineNo * lh - lh * 2);
            } catch (e) {}
          } catch (e) {}
        } catch (e) {}
      }

      // Create a step row (key input + value input + remove button) and append to `list`.
      // `baseName` is the field name, `keyVal` can be a string value or {key,val}.
      function createStepRow(baseName, keyVal, container, list) {
        const kv = { key: '', val: '' };
        if (keyVal && typeof keyVal === 'object') {
          kv.key = keyVal.key || '';
          kv.val = keyVal.val || '';
        } else if (typeof keyVal === 'string') {
          kv.val = keyVal;
        }

        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.gap = '8px';
        row.style.marginTop = '6px';

        const keyInp = document.createElement('input');
        keyInp.type = 'text';
        keyInp.name = baseName + '_key';
        keyInp.placeholder = 'key';
        keyInp.style.width = '80px';
        keyInp.autocomplete = 'off';

        let defaultKey = kv.key || '';
        if (!defaultKey && container && container.dataset) {
          if (container.dataset.keyMode === 'numbered') {
            const existing = list.querySelectorAll(`[name="${baseName}"]`);
            defaultKey = String(existing.length + 1) + '.';
          } else if (container.dataset.keyMode === 'bullet') {
            defaultKey = '-';
          }
        }
        keyInp.value = defaultKey;

        const inp = document.createElement('input');
        inp.type = 'text';
        inp.name = baseName;
        inp.id = baseName + '-' + ++dynamicIdCounter;
        inp.placeholder = 'Step';
        inp.autocomplete = 'off';
        if (kv.val) inp.value = kv.val;

        const remove = document.createElement('button');
        remove.type = 'button';
        remove.className = 'btn ghost';
        remove.textContent = '-';
        remove.addEventListener('click', () => {
          row.remove();
        });

        row.appendChild(keyInp);
        row.appendChild(inp);
        row.appendChild(remove);
        if (list) list.appendChild(row);
        return inp;
      }

      function build() {
        tabbar.innerHTML = '';
        contents.innerHTML = '';
        formConfig.forEach((tab, i) => {
          const t = document.createElement('div');
          t.className = 'tab';
          t.textContent = tab.title;
          t.dataset.index = i;
          t.addEventListener('click', () => activateTab(i));
          tabbar.appendChild(t);

          const pane = document.createElement('div');
          pane.className = 'tab-pane';
          pane.style.display = 'none';
          pane.dataset.index = i;

          // subtabs: Form and Populate
          const subtabs = document.createElement('div');
          subtabs.className = 'subtabs';
          const stForm = document.createElement('div');
          stForm.className = 'subtab active';
          stForm.textContent = 'Form';
          const stPop = document.createElement('div');
          stPop.className = 'subtab';
          stPop.textContent = 'Populate';
          subtabs.appendChild(stForm);
          subtabs.appendChild(stPop);
          pane.appendChild(subtabs);

          const formArea = document.createElement('div');
          formArea.className = 'tab-content form-area';
          const populateArea = document.createElement('div');
          populateArea.className = 'tab-content populate-area';
          populateArea.style.display = 'none';

          // build form
          const form = document.createElement('form');
          form.className = 'generated-form';
          form.autocomplete = 'off';
          tab.fields.forEach((f) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'field';
            // inline/side-by-side support: if field specifies `inline: true`,
            // render it as an inline-block and respect optional `width`.
            if (f && f.inline) {
              wrapper.className += ' field-inline';
              try {
                wrapper.style.width = f.width ? String(f.width) : '45%';
              } catch (e) {}
            }
            const label = document.createElement('label');
            if (f.type !== 'header') {
              label.textContent = f.label || f.name;
              wrapper.appendChild(label);
            }

            // Support header type: render headings instead of inputs. Accept
            // optional `level` (1-6) or `size` like 'h1'..'h6'. Default to h2.
            if (f.type === 'header') {
              try {
                let tag = 'h2';
                if (f && f.level && !Number.isNaN(Number(f.level))) {
                  const lv = Math.max(1, Math.min(6, Number(f.level)));
                  tag = 'h' + lv;
                } else if (f && f.size && /^h[1-6]$/.test(String(f.size))) {
                  tag = String(f.size);
                }
                const h = document.createElement(tag);
                h.className = 'field-header';
                h.textContent = f.label || f.name || '';
                wrapper.appendChild(h);
                form.appendChild(wrapper);
                return; // skip input creation
              } catch (e) {}
            }
            let input;
            if (f.type === 'textarea') {
              input = document.createElement('textarea');
              input.rows = 4;
              input.autocomplete = 'off';
            } else if (f.type === 'select') {
              input = document.createElement('select');
              (f.options || []).forEach((opt) => {
                const o = document.createElement('option');
                o.value = opt.value ?? opt;
                o.textContent = opt.label ?? opt;
                input.appendChild(o);
              });
              input.autocomplete = 'off';
            } else {
              input = document.createElement('input');
              input.type = f.type || 'text';
              input.autocomplete = 'off';
            }
            input.name = f.name;
            input.placeholder = f.placeholder || '';
            if (f.default) input.value = f.default;
            wrapper.appendChild(input);
            // Special handling for steps type: build dynamic list UI
            if (f.type === 'steps') {
              // Rename the top input to be the combined input so it does not
              // conflict with the per-step inputs below (which share the base name).
              input.name = f.name + '_combined';
              input.placeholder = 'Step 1 > Step 2 > Step 3';
              input.style.width = '70%';
              input.style.display = 'inline-block';

              const parseBtnTop = document.createElement('button');
              parseBtnTop.type = 'button';
              parseBtnTop.className = 'btn ghost';
              parseBtnTop.textContent = 'Parse';
              parseBtnTop.style.marginLeft = '8px';
              // place the combined input and button inside a row
              const combinedRow = document.createElement('div');
              combinedRow.style.display = 'flex';
              combinedRow.style.alignItems = 'center';
              combinedRow.style.gap = '8px';
              combinedRow.appendChild(input);
              combinedRow.appendChild(parseBtnTop);
              // If the field defines a default combined steps string, prefill and parse it
              if (f.default && typeof f.default === 'string' && f.default.trim()) {
                input.value = f.default;
              }
              wrapper.appendChild(combinedRow);
              if (f.default && typeof f.default === 'string' && f.default.trim()) {
                // trigger parse to populate individual step rows
                parseBtnTop.click();
              }
              // default key behavior selector (none | numbered)
              const controlRow = document.createElement('div');
              controlRow.style.display = 'flex';
              controlRow.style.alignItems = 'center';
              controlRow.style.gap = '8px';
              controlRow.style.marginTop = '8px';
              const modeLabel = document.createElement('div');
              modeLabel.className = 'meta';
              modeLabel.textContent = 'Default key:';
              const modeSelect = document.createElement('select');
              const oNone = document.createElement('option');
              oNone.value = 'none';
              oNone.textContent = 'None (blank)';
              const oNum = document.createElement('option');
              oNum.value = 'numbered';
              oNum.textContent = 'Numbered';
              const oBullet = document.createElement('option');
              oBullet.value = 'bullet';
              oBullet.textContent = 'Bullet (-)';
              modeSelect.appendChild(oNone);
              modeSelect.appendChild(oNum);
              modeSelect.appendChild(oBullet);
              // Allow step fields to declare a default key mode via `keyMode` in the field definition
              // Supported values: 'none' | 'numbered' | 'bullet'
              try {
                modeSelect.value = f && f.keyMode ? String(f.keyMode) : 'none';
              } catch (e) {
                modeSelect.value = 'none';
              }
              modeSelect.autocomplete = 'off';
              modeSelect.addEventListener('change', () => {
                container.dataset.keyMode = modeSelect.value;
              });
              controlRow.appendChild(modeLabel);
              controlRow.appendChild(modeSelect);
              wrapper.appendChild(controlRow);
              const container = document.createElement('div');
              container.className = 'steps-container';
              container.dataset.name = f.name;
              // initialize key mode on the container after it's created
              container.dataset.keyMode = modeSelect.value;

              const list = document.createElement('div');
              list.className = 'steps-list';

              const addBtn = document.createElement('button');
              addBtn.type = 'button';
              addBtn.className = 'btn';
              addBtn.textContent = '+ Add';
              addBtn.style.marginLeft = '8px';

              function addPathItem(val) {
                // val can be a string value or an object { key, val }
                const keyVal = { key: '', val: '' };
                if (val && typeof val === 'object') {
                  keyVal.key = val.key || '';
                  keyVal.val = val.val || '';
                } else if (typeof val === 'string') {
                  keyVal.val = val;
                }
                return createStepRow(f.name, keyVal, container, list);
              }

              // ensure at least one item exists so scanPopulate can detect the name
              addPathItem('');

              addBtn.addEventListener('click', () => addPathItem(''));
              // parse top combined input into steps
              parseBtnTop.addEventListener('click', () => {
                const parts = (input.value || '')
                  .split('>')
                  .map((s) => s.trim())
                  .filter(Boolean);
                list.innerHTML = '';
                if (parts.length === 0) {
                  addPathItem('');
                } else {
                  parts.forEach((p) => {
                    if (p.includes('=>')) {
                      const [k, ...rest] = p.split('=>');
                      const val = rest.join('=>').trim();
                      // When parsing a numbered key like "1" from a combined
                      // steps string, add the period so the per-step key field
                      // reflects the numbered style ("1."). If the key already
                      // included punctuation, preserve it.
                      let key = k.trim();
                      if (/^\d+$/.test(key)) key = key + '.';
                      addPathItem({ key, val });
                    } else {
                      addPathItem(p);
                    }
                  });
                }
              });
              wrapper.appendChild(container);
              container.appendChild(list);
              container.appendChild(addBtn);
              form.appendChild(wrapper);
            } else {
              form.appendChild(wrapper);
            }
          });

          // New and Duplicate buttons: create new tab blank or copy of current values
          const newBtn = document.createElement('button');
          newBtn.className = 'btn';
          newBtn.type = 'button';
          newBtn.textContent = 'New';
          newBtn.style.marginLeft = '8px';
          newBtn.addEventListener('click', () => {
            const allPrev = captureAllFormValues();
            try {
              const newForm = {
                title: (tab && tab.title ? tab.title : 'New') + ' (new)',
                format: tab && tab.format ? JSON.parse(JSON.stringify(tab.format)) : null,
                fields: JSON.parse(JSON.stringify(tab.fields || [])).map((f) => {
                  const nf = JSON.parse(JSON.stringify(f));
                  if (nf.hasOwnProperty('default')) delete nf.default;
                  return nf;
                }),
                _templateId:
                  formConfig[i] && formConfig[i]._templateId
                    ? formConfig[i]._templateId
                    : undefined,
              };
              formConfig.push(newForm);
              try {
                persistFormMap();
              } catch (e) {}
              build();
              try {
                restoreAllFormValues(allPrev);
              } catch (e) {}
              try {
                activateTab(formConfig.length - 1);
              } catch (e) {}
            } catch (e) {}
          });

          const dupBtn = document.createElement('button');
          dupBtn.className = 'btn';
          dupBtn.type = 'button';
          dupBtn.textContent = 'Duplicate';
          dupBtn.style.marginLeft = '8px';
          dupBtn.addEventListener('click', () => {
            const allPrev = captureAllFormValues();
            try {
              // capture current form values
              const vals = {};
              Array.from(form.elements).forEach((e) => {
                if (!e.name) return;
                const name = e.name;
                const v = e.type === 'checkbox' ? (e.checked ? e.value || 'on' : '') : e.value;
                if (Object.prototype.hasOwnProperty.call(vals, name)) {
                  if (!Array.isArray(vals[name])) vals[name] = [vals[name]];
                  vals[name].push(v);
                } else {
                  vals[name] = v;
                }
              });

              const newFields = (tab.fields || []).map((f) => {
                const nf = JSON.parse(JSON.stringify(f));
                if (f.type === 'steps') {
                  // prefer combined input if present
                  if (
                    Object.prototype.hasOwnProperty.call(vals, f.name + '_combined') &&
                    vals[f.name + '_combined']
                  ) {
                    nf.default = vals[f.name + '_combined'];
                  } else if (Object.prototype.hasOwnProperty.call(vals, f.name)) {
                    const v = vals[f.name];
                    if (Array.isArray(v)) nf.default = v.join(' > ');
                    else nf.default = v;
                  } else {
                    if (nf.hasOwnProperty('default')) delete nf.default;
                  }
                } else {
                  if (Object.prototype.hasOwnProperty.call(vals, f.name)) nf.default = vals[f.name];
                  else if (nf.hasOwnProperty('default')) delete nf.default;
                }
                return nf;
              });

              const newForm = {
                title: (tab && tab.title ? tab.title : 'Copy') + ' (copy)',
                format: tab && tab.format ? JSON.parse(JSON.stringify(tab.format)) : null,
                fields: newFields,
                _templateId:
                  formConfig[i] && formConfig[i]._templateId
                    ? formConfig[i]._templateId
                    : undefined,
              };
              formConfig.push(newForm);
              try {
                persistFormMap();
              } catch (e) {}
              build();
              try {
                restoreAllFormValues(allPrev);
              } catch (e) {}
              try {
                activateTab(formConfig.length - 1);
              } catch (e) {}
            } catch (e) {}
          });

          // top-of-page clear button for this tab's form
          const topClear = document.createElement('button');
          topClear.className = 'btn warn';
          topClear.type = 'button';
          topClear.textContent = 'Clear';
          topClear.style.marginLeft = '8px';
          topClear.addEventListener('click', () => {
            Array.from(form.elements).forEach((e) => {
              if (!e.name) return;
              try {
                if (e.type === 'checkbox' || e.type === 'radio') e.checked = false;
                else e.value = '';
              } catch (err) {}
            });
          });

          formArea.appendChild(newBtn);
          formArea.appendChild(dupBtn);
          formArea.appendChild(topClear);

          // give the last appended control spacing before the form
          try {
            const last = formArea.lastElementChild;
            if (last && last.style) last.style.marginBottom = '8px';
          } catch (e) {}

          formArea.appendChild(form);

          // template selector
          const tplRow = document.createElement('div');
          tplRow.style.display = 'flex';
          tplRow.style.alignItems = 'center';
          tplRow.style.gap = '8px';
          tplRow.style.marginTop = '6px';
          const tplLabel = document.createElement('div');
          tplLabel.className = 'meta';
          tplLabel.textContent = 'Template:';
          const tplSelect = document.createElement('select');
          tplSelect.autocomplete = 'off';
          tplSelect.style.padding = '6px';
          tplSelect.style.borderRadius = '6px';
          tplSelect.style.border = '1px solid var(--border)';
          forms.forEach((tpl) => {
            const o = document.createElement('option');
            o.value = tpl.id;
            o.textContent = tpl.label;

            tplSelect.appendChild(o);
          });
          // default to this tab's configured template if present
          if (formConfig[i] && formConfig[i]._templateId)
            tplSelect.value = formConfig[i]._templateId;
          // when a template is selected, only update this tab's output format
          // and mapping. Changing the generate-template dropdown must never
          // alter the form's fields or trigger a DOM rebuild.
          tplSelect.addEventListener('change', () => {
            const sel = tplSelect.value || '__json__';
            const tpl = formsMap[sel];
            if (!tpl) return;
            try {
              // Only apply format when the template explicitly defines `cfg`.
              // A null/blank cfg clears prior formats; absence of `cfg` means
              // the template should not change the output formatting.
              if (Object.prototype.hasOwnProperty.call(tpl, 'cfg')) {
                formConfig[i].format = tpl.cfg ? JSON.parse(JSON.stringify(tpl.cfg)) : null;
              }
              formConfig[i]._templateId = sel;
              persistFormMap();
            } catch (e) {}
            // Do NOT call build(), do NOT change formConfig[i].fields, and
            // do NOT activate tabs — selection only affects generation output.
          });
          tplRow.appendChild(tplLabel);
          tplRow.appendChild(tplSelect);
          // if dev mode is enabled, expose an Unload button for this form
          if (devMode) {
            const unloadBtn = document.createElement('button');
            unloadBtn.type = 'button';
            unloadBtn.className = 'btn warn';
            unloadBtn.textContent = 'Unload';
            unloadBtn.style.marginLeft = '8px';
            unloadBtn.addEventListener('click', () => {
              try {
                const tid = formConfig[i] && formConfig[i]._templateId;
                if (tid && /^tpl-(\d+)$/.test(tid)) {
                  alert('Cannot unload a default form tab.');
                  return;
                }
                // remove this form tab
                const allPrev = captureAllFormValues();
                formConfig.splice(i, 1);
                try {
                  persistFormMap();
                } catch (e) {}
                try {
                  build();
                } catch (e) {}
                try {
                  restoreAllFormValues(allPrev);
                } catch (e) {}
                try {
                  activateTab(Math.max(0, i - 1));
                } catch (e) {}
              } catch (e) {}
            });
            tplRow.appendChild(unloadBtn);
          }
          formArea.appendChild(tplRow);

          // --- Generate UI: button + output area
          const genWrapper = document.createElement('div');
          genWrapper.style.marginTop = '12px';
          const genBtn = document.createElement('button');
          genBtn.className = 'btn';
          genBtn.type = 'button';
          genBtn.textContent = 'Generate';
          const copyBtn = document.createElement('button');
          copyBtn.className = 'btn ghost';
          copyBtn.type = 'button';
          copyBtn.textContent = 'Copy';
          copyBtn.style.marginLeft = '8px';
          const clearOutBtn = document.createElement('button');
          clearOutBtn.className = 'btn ghost';
          clearOutBtn.type = 'button';
          clearOutBtn.textContent = 'Clear';
          clearOutBtn.style.marginLeft = '8px';
          const out = document.createElement('textarea');
          out.readOnly = true;
          out.rows = 10;
          out.autocomplete = 'off';
          out.style.width = '100%';
          out.style.marginTop = '8px';
          out.style.padding = '8px';
          out.style.borderRadius = '6px';
          out.style.border = '1px solid #eee';
          genWrapper.appendChild(genBtn);
          genWrapper.appendChild(copyBtn);
          genWrapper.appendChild(clearOutBtn);
          genWrapper.appendChild(out);
          formArea.appendChild(genWrapper);

          genBtn.addEventListener('click', () => {
            const values = {};
            Array.from(form.elements).forEach((e) => {
              if (!e.name) return;
              const v = e.value !== undefined ? e.value : '';
              if (Object.prototype.hasOwnProperty.call(values, e.name)) {
                if (!Array.isArray(values[e.name])) values[e.name] = [values[e.name]];
                values[e.name].push(v);
              } else {
                values[e.name] = v;
              }
            });
            // Combine key=>value pairs for fields that have an associated _key input
            Object.keys(values).forEach((k) => {
              if (!k.endsWith('_key')) return;
              const base = k.slice(0, -4);
              if (!Object.prototype.hasOwnProperty.call(values, base)) return;
              const keys = Array.isArray(values[k]) ? values[k] : [values[k]];
              const vals = Array.isArray(values[base]) ? values[base] : [values[base]];
              const combined = vals.map((v, i) => {
                const keyRaw = keys[i] || '';
                let prefix = '';
                // Do not automatically append a period to numeric keys here;
                // only preserve what the user entered. If the key already
                // contains a period, it will be preserved.
                if (/^\d+$/.test(keyRaw)) prefix = keyRaw + ' ';
                else if (keyRaw) prefix = keyRaw + ' ';
                return prefix + v;
              });
              values[base] = combined.length === 1 ? combined[0] : combined;
              // optionally remove the keys entry
              delete values[k];
            });
            const sel = tplSelect.value || '__json__';
            const cfg = formsMap[sel] && formsMap[sel].cfg ? formsMap[sel].cfg : null;
            out.value = generateOutput(cfg, values);
            // Auto-resize the output textarea to fit the generated content
            try {
              out.style.height = 'auto';
              out.style.overflow = 'hidden';
              out.style.height = out.scrollHeight + 'px';
            } catch (e) {}
          });
          copyBtn.addEventListener('click', async () => {
            const text = out.value || '';
            try {
              if (navigator.clipboard && navigator.clipboard.writeText) {
                await navigator.clipboard.writeText(text);
              } else {
                out.select();
                document.execCommand('copy');
              }
              alert('Copied:\n' + text);
            } catch (err) {
              try {
                out.select();
                document.execCommand('copy');
                alert('Copied:\n' + text);
              } catch (e) {
                alert('Copy failed');
              }
            }
          });
          clearOutBtn.addEventListener('click', () => {
            out.value = '';
            try {
              autosizeTextarea(out);
            } catch (e) {}
          });

          // populate area UI
          const info = document.createElement('div');
          info.className = 'meta';
          info.textContent = 'Scan other tabs for values with matching field names.';
          const scanBtn = document.createElement('button');
          scanBtn.className = 'btn ghost';
          scanBtn.type = 'button';
          scanBtn.textContent = 'Scan';
          const autoBtn = document.createElement('button');
          autoBtn.className = 'btn';
          autoBtn.type = 'button';
          autoBtn.style.marginLeft = '8px';
          autoBtn.textContent = 'Auto Apply All';
          const preview = document.createElement('div');
          preview.className = 'preview-list';
          preview.style.marginTop = '12px';

          populateArea.appendChild(info);
          populateArea.appendChild(scanBtn);
          populateArea.appendChild(autoBtn);
          populateArea.appendChild(preview);

          pane.appendChild(formArea);
          pane.appendChild(populateArea);
          contents.appendChild(pane);

          // subtabs switching
          stForm.addEventListener('click', () => {
            stForm.classList.add('active');
            stPop.classList.remove('active');
            formArea.style.display = 'block';
            populateArea.style.display = 'none';
          });
          stPop.addEventListener('click', () => {
            stPop.classList.add('active');
            stForm.classList.remove('active');
            formArea.style.display = 'none';
            populateArea.style.display = 'block';
            scanPopulate(i, preview);
          });

          // actions
          scanBtn.addEventListener('click', () => scanPopulate(i, preview));
          autoBtn.addEventListener('click', () => {
            const items = scanPopulate(i, preview);
            const selections = [];
            items.forEach((it) => {
              if (it.candidates && it.candidates.length > 0) {
                const c = it.candidates[0];
                selections.push({ name: it.name, value: c.value });
              }
            });
            applyPreviewSelections(i, selections);
          });
        });

        // Add a dedicated 'Outputs' tab where outputs (generation formats + fields) can be edited.
        // Only add when devMode is enabled.
        (function addOutputsTab() {
          if (!devMode) return;
          const outIndex = formConfig.length;
          const outTab = document.createElement('div');
          outTab.className = 'tab right';
          outTab.textContent = 'Outputs';
          outTab.dataset.index = outIndex;
          outTab.addEventListener('click', () => activateTab(outIndex));
          tabbar.appendChild(outTab);

          const outPane = document.createElement('div');
          outPane.className = 'tab-pane';
          outPane.style.display = 'none';
          outPane.dataset.index = outIndex;

          const outContent = document.createElement('div');
          outContent.className = 'tab-content';
          const outLabel = document.createElement('label');
          outLabel.textContent = 'Outputs';
          outContent.appendChild(outLabel);

          const helpOut = document.createElement('div');
          helpOut.className = 'meta';
          helpOut.style.marginTop = '8px';
          helpOut.textContent =
            'Create and edit Outputs (format + fields). Outputs can be used as the basis for Forms.';
          outContent.appendChild(helpOut);

          const selectorRow = document.createElement('div');
          selectorRow.style.display = 'flex';
          selectorRow.style.alignItems = 'center';
          selectorRow.style.gap = '8px';
          selectorRow.style.marginTop = '8px';
          const outList = document.createElement('select');
          outList.autocomplete = 'off';
          outList.style.flex = '1';
          const outNewBtn = document.createElement('button');
          outNewBtn.type = 'button';
          outNewBtn.className = 'btn';
          outNewBtn.textContent = '+ New';
          selectorRow.appendChild(outList);
          selectorRow.appendChild(outNewBtn);
          outContent.appendChild(selectorRow);

          const lblRow = document.createElement('div');
          lblRow.style.marginTop = '8px';
          const lblLbl = document.createElement('label');
          lblLbl.textContent = 'Label';
          const lblIn = document.createElement('input');
          lblIn.type = 'text';
          lblIn.style.width = '100%';
          lblIn.autocomplete = 'off';
          lblRow.appendChild(lblLbl);
          lblRow.appendChild(lblIn);
          outContent.appendChild(lblRow);

          const cfgLbl = document.createElement('label');
          cfgLbl.textContent = 'Template';
          cfgLbl.style.marginTop = '8px';
          // advanced toggle for Outputs: hide/show resolved JSON + resolve button
          const advRowOut = document.createElement('div');
          advRowOut.style.display = 'flex';
          advRowOut.style.alignItems = 'center';
          advRowOut.style.gap = '8px';
          advRowOut.style.marginTop = '6px';
          const advChkOut = document.createElement('input');
          advChkOut.type = 'checkbox';
          advChkOut.autocomplete = 'off';
          const advLblOut = document.createElement('div');
          advLblOut.className = 'meta';
          advLblOut.textContent = 'Advanced (raw JSON)';
          advRowOut.appendChild(advChkOut);
          advRowOut.appendChild(advLblOut);
          // simple template input where user can type a template string
          const cfgSimpleOut = document.createElement('textarea');
          cfgSimpleOut.rows = 2;
          cfgSimpleOut.style.width = '100%';
          cfgSimpleOut.placeholder = 'Hello {firstName}';
          cfgSimpleOut.autocomplete = 'off';
          // button to resolve the simple template into editable JSON
          const resolveBtn = document.createElement('button');
          resolveBtn.type = 'button';
          resolveBtn.className = 'btn ghost';
          resolveBtn.textContent = 'Resolve to JSON';
          resolveBtn.style.marginTop = '6px';
          // raw JSON textarea (editable resolved JSON)
          const cfgTaOut = document.createElement('textarea');
          cfgTaOut.rows = 6;
          cfgTaOut.style.width = '100%';
          cfgTaOut.placeholder = '{ "type": "template", "template": "Hello {firstName}" }';
          cfgTaOut.autocomplete = 'off';
          outContent.appendChild(cfgLbl);
          outContent.appendChild(advRowOut);
          outContent.appendChild(cfgSimpleOut);
          outContent.appendChild(resolveBtn);
          outContent.appendChild(cfgTaOut);
          // default to simple view: hide resolved JSON textarea and resolve button
          try {
            cfgTaOut.style.display = 'none';
            resolveBtn.style.display = 'none';
          } catch (e) {}
          advChkOut.addEventListener('change', () => {
            if (advChkOut.checked) {
              cfgTaOut.style.display = '';
              resolveBtn.style.display = '';
            } else {
              cfgTaOut.style.display = 'none';
              resolveBtn.style.display = 'none';
            }
          });
          resolveBtn.addEventListener('click', () => {
            try {
              const raw = String(cfgSimpleOut.value || '').trim();
              if (!raw) {
                cfgTaOut.value = '';
                autosizeTextarea(cfgTaOut);
                return;
              }
              if (raw[0] === '{' || raw[0] === '[') {
                try {
                  const parsed = JSON.parse(raw);
                  cfgTaOut.value = JSON.stringify(parsed, null, 2);
                  autosizeTextarea(cfgTaOut);
                } catch (e) {
                  // not valid JSON, treat as template string
                  cfgTaOut.value = JSON.stringify({ type: 'template', template: raw }, null, 2);
                  autosizeTextarea(cfgTaOut);
                }
              } else {
                cfgTaOut.value = JSON.stringify({ type: 'template', template: raw }, null, 2);
                autosizeTextarea(cfgTaOut);
              }
            } catch (e) {}
          });

          const fieldsLblOut = document.createElement('label');
          fieldsLblOut.textContent = 'Fields (JSON array)';
          fieldsLblOut.style.marginTop = '8px';
          const fieldsTaOut = document.createElement('textarea');
          fieldsTaOut.rows = 8;
          fieldsTaOut.style.width = '100%';
          fieldsTaOut.placeholder = '[ { "label": "Name", "name": "firstName", "type": "text" } ]';
          fieldsTaOut.autocomplete = 'off';
          outContent.appendChild(fieldsLblOut);
          outContent.appendChild(fieldsTaOut);

          const saveOutBtn = document.createElement('button');
          saveOutBtn.className = 'btn';
          saveOutBtn.type = 'button';
          saveOutBtn.textContent = 'Save';
          const genOutBtn = document.createElement('button');
          genOutBtn.className = 'btn ghost';
          genOutBtn.type = 'button';
          genOutBtn.textContent = 'Generate Fields From Output';
          genOutBtn.style.marginLeft = '8px';
          const delOutBtn = document.createElement('button');
          delOutBtn.className = 'btn warn';
          delOutBtn.type = 'button';
          delOutBtn.textContent = 'Delete';
          delOutBtn.style.marginLeft = '8px';
          const createFormBtn = document.createElement('button');
          createFormBtn.className = 'btn ghost';
          createFormBtn.type = 'button';
          createFormBtn.textContent = 'Create Form from Output';
          createFormBtn.style.marginLeft = '8px';
          outContent.appendChild(saveOutBtn);
          outContent.appendChild(genOutBtn);
          outContent.appendChild(delOutBtn);
          outContent.appendChild(createFormBtn);

          function refreshOutList() {
            outList.innerHTML = '';
            outputs.forEach((o) => {
              const op = document.createElement('option');
              op.value = o.id;
              op.textContent = o.label || o.id;
              outList.appendChild(op);
            });
          }
          refreshOutList();

          function loadOut() {
            const id = outList.value;
            const o = outputs.find((x) => x.id === id);
            if (!o) {
              lblIn.value = '';
              try {
                cfgSimpleOut.value = '';
                autosizeTextarea(cfgSimpleOut);
              } catch (e) {}
              try {
                cfgTaOut.value = '';
                autosizeTextarea(cfgTaOut);
              } catch (e) {}
              try {
                advChkOut.checked = false;
                cfgTaOut.style.display = 'none';
                resolveBtn.style.display = 'none';
              } catch (e) {}
              fieldsTaOut.value = '';
              autosizeTextarea(fieldsTaOut);
              return;
            }
            lblIn.value = o.label || '';
            try {
              if (
                o.cfg &&
                typeof o.cfg === 'object' &&
                o.cfg.type === 'template' &&
                typeof o.cfg.template === 'string'
              ) {
                cfgSimpleOut.value = o.cfg.template;
                autosizeTextarea(cfgSimpleOut);
                cfgTaOut.value = JSON.stringify(o.cfg, null, 2);
                autosizeTextarea(cfgTaOut);
                try {
                  advChkOut.checked = false;
                  cfgTaOut.style.display = 'none';
                  resolveBtn.style.display = 'none';
                } catch (e) {}
              } else {
                cfgSimpleOut.value = '';
                autosizeTextarea(cfgSimpleOut);
                cfgTaOut.value = o.cfg ? JSON.stringify(o.cfg, null, 2) : '';
                autosizeTextarea(cfgTaOut);
                try {
                  advChkOut.checked = true;
                  cfgTaOut.style.display = '';
                  resolveBtn.style.display = '';
                } catch (e) {}
              }
            } catch (e) {
              cfgTaOut.value = '';
              autosizeTextarea(cfgTaOut);
            }
            try {
              fieldsTaOut.value = o.fields ? JSON.stringify(o.fields, null, 2) : '';
              autosizeTextarea(fieldsTaOut);
            } catch (e) {
              fieldsTaOut.value = '';
              autosizeTextarea(fieldsTaOut);
            }
          }
          outList.addEventListener('change', loadOut);
          loadOut();

          outNewBtn.addEventListener('click', () => {
            const id = `out-${Date.now()}`;
            const no = { id, label: id, cfg: null, fields: [] };
            outputs.push(no);
            outputsMap = Object.fromEntries(outputs.map((x) => [x.id, x]));
            localStorage.setItem(outputsKey, JSON.stringify(outputs));
            refreshOutList();
            outList.value = id;
            loadOut();
            try {
              const tplOut = document.querySelector('select[data-outputs-selector="true"]');
              if (tplOut) {
                tplOut.innerHTML = '';
                outputs.forEach((o) => {
                  const op = document.createElement('option');
                  op.value = o.id;
                  op.textContent = o.label || o.id;
                  tplOut.appendChild(op);
                });
              }
            } catch (e) {}
          });

          saveOutBtn.addEventListener('click', () => {
            const id = outList.value;
            const o = outputs.find((x) => x.id === id);
            if (!o) return;
            o.label = lblIn.value || o.label || o.id;
            try {
              const jsonRaw = String(cfgTaOut.value || '').trim();
              const simpleRaw = String(cfgSimpleOut.value || '').trim();
              if (jsonRaw) {
                try {
                  o.cfg = JSON.parse(jsonRaw);
                } catch (e) {
                  // If the user edited the resolved JSON but it's not valid JSON
                  // and it doesn't look like JSON, treat it as a plain template
                  // string to preserve backwards compatibility.
                  if (jsonRaw[0] === '{' || jsonRaw[0] === '[') throw e;
                  o.cfg = { type: 'template', template: jsonRaw };
                }
              } else if (simpleRaw) {
                o.cfg = { type: 'template', template: simpleRaw };
              } else {
                o.cfg = null;
              }
            } catch (e) {
              try {
                highlightJsonError(cfgTaOut, e);
              } catch (ex) {}
              alert('Invalid output JSON: ' + e.message);
              return;
            }
            try {
              const parsedF = fieldsTaOut.value.trim() ? JSON.parse(fieldsTaOut.value) : [];
              if (!Array.isArray(parsedF)) throw new Error('Fields must be an array');
              // Do not auto-generate fields from the template when saving — respect
              // whatever the user has entered in the Fields textarea. Only validate
              // that it's a JSON array and then save it.
              o.fields = parsedF;
            } catch (e) {
              try {
                highlightJsonError(fieldsTaOut, e);
              } catch (ex) {}
              alert('Invalid fields JSON: ' + e.message);
              return;
            }
            outputsMap = Object.fromEntries(outputs.map((x) => [x.id, x]));
            // persist outputs so Templates can reference them later
            try {
              localStorage.setItem(outputsKey, JSON.stringify(outputs));
            } catch (e) {}
            refreshOutList();
            loadOut();
            try {
              const tplOut = document.querySelector('select[data-outputs-selector="true"]');
              if (tplOut) {
                tplOut.innerHTML = '';
                outputs.forEach((o) => {
                  const op = document.createElement('option');
                  op.value = o.id;
                  op.textContent = o.label || o.id;
                  tplOut.appendChild(op);
                });
              }
            } catch (e) {}
          });

          // Populate the Fields textarea by extracting placeholder variables
          // from the output `template` string (preview only, does not save).
          genOutBtn.addEventListener('click', () => {
            try {
              let parsed = null;
              const jsonRaw = String(cfgTaOut.value || '').trim();
              const simpleRaw = String(cfgSimpleOut.value || '').trim();
              if (jsonRaw) {
                try {
                  parsed = JSON.parse(jsonRaw);
                } catch (e) {
                  // fallback to treating as template string
                  parsed = { type: 'template', template: jsonRaw };
                }
              } else if (simpleRaw) {
                parsed = { type: 'template', template: simpleRaw };
              }
              const gen = [];
              if (parsed && typeof parsed.template === 'string') {
                const tpl = parsed.template;
                const re = /\{([a-zA-Z0-9_]+)\}/g;
                const seen = new Set();
                let m;
                while ((m = re.exec(tpl)) !== null) {
                  const name = m[1];
                  if (seen.has(name)) continue;
                  seen.add(name);
                  const label =
                    name === 'steps' ? 'Steps' : name.charAt(0).toUpperCase() + name.slice(1);
                  const type = name === 'steps' ? 'steps' : 'text';
                  const fld = { label, name, type, placeholder: '' };
                  if (type === 'steps') fld.keyMode = '';
                  gen.push(fld);
                }
              }
              fieldsTaOut.value = JSON.stringify(gen, null, 2);
              autosizeTextarea(fieldsTaOut);
            } catch (e) {
              try {
                highlightJsonError(cfgTaOut, e);
              } catch (ex) {}
              alert('Invalid output JSON: ' + e.message);
            }
          });

          delOutBtn.addEventListener('click', () => {
            try {
              var _proceed = true;
              try {
                if (typeof navigator !== 'undefined' && /jsdom/i.test(navigator.userAgent)) {
                  _proceed = true; // auto-accept in test/jsdom environment
                } else if (typeof window.confirm === 'function') {
                  _proceed = !!window.confirm('Delete this output? This action cannot be undone.');
                }
              } catch (e) {
                _proceed = true;
              }
              if (!_proceed) return;
            } catch (e) {}
            const id = outList.value;
            outputs = outputs.filter((x) => x.id !== id);
            outputsMap = Object.fromEntries(outputs.map((x) => [x.id, x]));
            localStorage.setItem(outputsKey, JSON.stringify(outputs));
            refreshOutList();
            loadOut();
            try {
              const tplOut = document.querySelector('select[data-outputs-selector="true"]');
              if (tplOut) {
                tplOut.innerHTML = '';
                outputs.forEach((o) => {
                  const op = document.createElement('option');
                  op.value = o.id;
                  op.textContent = o.label || o.id;
                  tplOut.appendChild(op);
                });
              }
            } catch (e) {}
          });

          // The original "Create Form from Output" action is intentionally
          // disabled — outputs are intended to define generation formats and
          // their inferred fields, not to implicitly create form tabs.
          try {
            createFormBtn.style.display = 'none';
          } catch (e) {}

          outPane.appendChild(outContent);
          contents.appendChild(outPane);
        })();

        // Add a dedicated 'Templates' tab where the templates JSON can be edited.
        // Only add when devMode is enabled.
        (function addTemplatesTab() {
          if (!devMode) return;
          const tplIndex = formConfig.length + 1;
          const tplTab = document.createElement('div');
          tplTab.className = 'tab right';
          tplTab.textContent = 'Forms';
          tplTab.dataset.index = tplIndex;
          tplTab.addEventListener('click', () => activateTab(tplIndex));
          tabbar.appendChild(tplTab);

          const tplPane = document.createElement('div');
          tplPane.className = 'tab-pane';
          tplPane.style.display = 'none';
          tplPane.dataset.index = tplIndex;

          const paneContent = document.createElement('div');
          paneContent.className = 'tab-content';
          const label = document.createElement('label');
          label.textContent = 'Forms';
          paneContent.appendChild(label);

          // Inline help explaining how to edit templates
          const help = document.createElement('div');
          help.className = 'meta';
          help.style.marginTop = '8px';
          help.innerHTML = `
            <strong>How to edit forms:</strong>
            <ul style="margin:6px 0 0 18px;padding:0;">
              <li>Select an existing form-definition or click <em>+ New</em> to create one.</li>
              <li><em>Label</em>: a friendly name shown in selects.</li>
              <li>
                <em>Template</em>: a JSON object that controls output formatting. Common forms:
                <ul>
                  <li><strong>type: "template"</strong> — use placeholders like <code>{firstName}</code>. When a field exposes a combined input (see <em>Fields</em> below), you can reference the combined value as <code>{fieldName_combined}</code> or the explicit per-field value as <code>{fieldName}</code>.</li>
                  <li><strong>type: "sprintf"</strong> — use Python-style tokens like <code>%(firstName)s</code>.</li>
                  <li><strong>Blank/JSON fallback</strong> — leave the template blank to output raw JSON.</li>
                </ul>
              </li>
              <li>
                <em>Fields</em>: a JSON array of field definitions. Example:
                <code>[ { "label": "Name", "name": "firstName", "type": "text" } ]</code>.
                For step-like fields use <code>"type":"steps"</code>. A steps field provides:
                <ul>
                  <li>a top combined input named <code>FIELD_combined</code> (e.g. <code>tasks_combined</code>) where users enter values like <code>Step 1 &gt; Step 2</code>;</li>
                  <li>and per-step inputs named <code>FIELD</code> (plus optional <code>FIELD_key</code>) created when parsing the combined string.</li>
                </ul>
                The generator prefers the combined input when present (use <code>{FIELD_combined}</code> in templates), but form-definitions can also handle arrays or combined strings — the runtime will format arrays as numbered lists when appropriate.
                <p>To include headings inside the form, add a field with <code>"type":"header"</code>. Use <code>label</code> for the heading text and optionally <code>level</code> (1-6) or <code>size</code> (<code>h1</code>.. <code>h6</code>) to control the heading element.</p>
                <p>To layout fields side-by-side, set a field's <code>inline</code> property to <code>true</code> and optionally provide <code>width</code> (e.g. <code>"45%"</code> or <code>"200px"</code>); default width is <code>45%</code>.</p>
                <p>Fields support an optional <code>placeholder</code> property. When generating fields from a template, placeholders default to an empty string.</p>
                <p><strong>Steps fields:</strong> step-like fields (<code>"type":"steps"</code>) now support a <code>keyMode</code> property to control the default per-step key style. Supported values:
                <code>"none"</code> (no key), <code>"numbered"</code> (1., 2., ...), or <code>"bullet"</code> (-). Example field definition:
                <pre style="background:#f4f7fb;padding:8px;border-radius:6px;margin:6px 0;">{ "label": "Tasks", "name": "tasks", "type": "steps", "keyMode": "numbered" }</pre>
                When a form defines <code>keyMode</code> the steps UI will initialize the Default key selector accordingly so parsed or added step rows inherit that style.</p>
              </li>
              <li>Click <em>Save</em> to apply — left-side form tabs update immediately and form definitions are persisted to localStorage (only form definitions are saved; user-entered form values are never persisted).</li>
            </ul>`;
          paneContent.appendChild(help);
          // Add brief export instructions to the Forms pane so users know how to
          // generate an HTML export of the configuration.
          const exportHelp = document.createElement('div');
          exportHelp.className = 'meta';
          exportHelp.style.marginTop = '8px';
          exportHelp.textContent =
            'To export the current forms and outputs, use the Export HTML button in the header — you can save to a file or copy the exported HTML to your clipboard.';
          paneContent.appendChild(exportHelp);

          // (Outputs selector moved below so Templates select remains the first select in the pane)

          const tplSelectorRow = document.createElement('div');
          tplSelectorRow.style.display = 'flex';
          tplSelectorRow.style.alignItems = 'center';
          tplSelectorRow.style.gap = '8px';
          tplSelectorRow.style.marginTop = '8px';
          const tplSelect = document.createElement('select');
          tplSelect.autocomplete = 'off';
          tplSelect.style.flex = '1';
          const addBtn = document.createElement('button');
          addBtn.type = 'button';
          addBtn.className = 'btn';
          addBtn.textContent = '+ New';
          tplSelectorRow.appendChild(tplSelect);
          tplSelectorRow.appendChild(addBtn);
          paneContent.appendChild(tplSelectorRow);

          // Outputs selector for choosing an existing output before creating a template
          const outSelectorRow = document.createElement('div');
          outSelectorRow.style.display = 'flex';
          outSelectorRow.style.alignItems = 'center';
          outSelectorRow.style.gap = '8px';
          outSelectorRow.style.marginTop = '8px';
          const outSelect = document.createElement('select');
          outSelect.autocomplete = 'off';
          outSelect.style.flex = '1';
          outSelect.dataset.outputsSelector = 'true';
          function refreshOutSelect() {
            outSelect.innerHTML = '';
            outputs.forEach((o) => {
              const op = document.createElement('option');
              op.value = o.id;
              op.textContent = o.label || o.id;
              outSelect.appendChild(op);
            });
          }
          refreshOutSelect();
          // When an Output is selected in the Forms pane, populate the
          // Template (JSON) and Fields textareas with that Output's data.
          function loadSelectedOutput() {
            const id = outSelect.value;
            const o = outputsMap[id] || outputs.find((x) => x.id === id) || null;
            if (!o) {
              try {
                cfgTa.value = '';
              } catch (e) {}
              try {
                fieldsTa.value = '';
              } catch (e) {}
              return;
            }
            try {
              if (
                o.cfg &&
                typeof o.cfg === 'object' &&
                o.cfg.type === 'template' &&
                typeof o.cfg.template === 'string'
              ) {
                try {
                  if (typeof cfgSimple !== 'undefined' && typeof advChk !== 'undefined') {
                    cfgSimple.value = o.cfg.template;
                    cfgTa.value = JSON.stringify(o.cfg, null, 2);
                    autosizeTextarea(cfgSimple);
                    autosizeTextarea(cfgTa);
                    advChk.checked = false;
                    cfgTa.style.display = 'none';
                    cfgSimple.style.display = '';
                  } else {
                    cfgTa.value = o.cfg.template;
                  }
                } catch (e) {
                  cfgTa.value = o.cfg.template;
                }
              } else {
                try {
                  if (typeof cfgSimple !== 'undefined' && typeof advChk !== 'undefined') {
                    cfgTa.value = o.cfg ? JSON.stringify(o.cfg, null, 2) : '';
                    cfgSimple.value = '';
                    autosizeTextarea(cfgSimple);
                    autosizeTextarea(cfgTa);
                    advChk.checked = true;
                    cfgTa.style.display = '';
                    cfgSimple.style.display = 'none';
                  } else {
                    cfgTa.value = o.cfg ? JSON.stringify(o.cfg, null, 2) : '';
                    autosizeTextarea(cfgTa);
                  }
                } catch (e) {
                  cfgTa.value = o.cfg ? JSON.stringify(o.cfg, null, 2) : '';
                  autosizeTextarea(cfgTa);
                }
              }
            } catch (e) {
              cfgTa.value = '';
              autosizeTextarea(cfgTa);
            }
            try {
              fieldsTa.value = o.fields ? JSON.stringify(o.fields, null, 2) : '';
              autosizeTextarea(fieldsTa);
            } catch (e) {
              fieldsTa.value = '';
              autosizeTextarea(fieldsTa);
            }
          }
          outSelect.addEventListener('change', loadSelectedOutput);
          // initialize the panes with the selected output (if any)
          try {
            loadSelectedOutput();
          } catch (e) {}
          const outLabel = document.createElement('div');
          outLabel.className = 'meta';
          outLabel.textContent = 'Output:';
          outSelectorRow.appendChild(outLabel);
          outSelectorRow.appendChild(outSelect);
          paneContent.appendChild(outSelectorRow);

          const labelRow = document.createElement('div');
          labelRow.style.marginTop = '8px';
          const lblLabel = document.createElement('label');
          lblLabel.textContent = 'Label';
          const lblInput = document.createElement('input');
          lblInput.type = 'text';
          lblInput.style.width = '100%';
          lblInput.autocomplete = 'off';
          labelRow.appendChild(lblLabel);
          labelRow.appendChild(lblInput);
          paneContent.appendChild(labelRow);

          const cfgLabel = document.createElement('label');
          cfgLabel.textContent = 'Template (JSON)';
          cfgLabel.style.marginTop = '8px';
          // raw JSON textarea (advanced)
          const cfgTa = document.createElement('textarea');
          cfgTa.rows = 6;
          cfgTa.style.width = '100%';
          cfgTa.placeholder = '{ "type": "template", "template": "Hello {firstName}" }';
          cfgTa.autocomplete = 'off';
          // simple template input for non-advanced users
          const cfgSimple = document.createElement('textarea');
          cfgSimple.rows = 2;
          cfgSimple.style.width = '100%';
          cfgSimple.placeholder = 'Hello {firstName}';
          cfgSimple.autocomplete = 'off';
          // advanced toggle
          const advRow = document.createElement('div');
          advRow.style.display = 'flex';
          advRow.style.alignItems = 'center';
          advRow.style.gap = '8px';
          advRow.style.marginTop = '6px';
          const advChk = document.createElement('input');
          advChk.type = 'checkbox';
          advChk.autocomplete = 'off';
          const advLbl = document.createElement('div');
          advLbl.className = 'meta';
          advLbl.textContent = 'Advanced (raw JSON)';
          advRow.appendChild(advChk);
          advRow.appendChild(advLbl);
          paneContent.appendChild(cfgLabel);
          paneContent.appendChild(advRow);
          paneContent.appendChild(cfgTa);
          // default to simple view
          cfgTa.style.display = 'none';
          advChk.addEventListener('change', () => {
            if (advChk.checked) {
              cfgTa.style.display = '';
              cfgSimple.style.display = 'none';
            } else {
              cfgTa.style.display = 'none';
              cfgSimple.style.display = '';
            }
          });

          const fieldsLabel = document.createElement('label');
          fieldsLabel.textContent = 'Fields (JSON array)';
          fieldsLabel.style.marginTop = '8px';
          const fieldsTa = document.createElement('textarea');
          fieldsTa.rows = 8;
          fieldsTa.style.width = '100%';
          fieldsTa.placeholder = '[ { "label": "Name", "name": "firstName", "type": "text" } ]';
          fieldsTa.autocomplete = 'off';
          paneContent.appendChild(fieldsLabel);
          paneContent.appendChild(fieldsTa);
          // append the simple template textarea after the fields textarea so
          // existing tests that index textareas continue to work (fields textarea
          // remains the second textarea)
          paneContent.appendChild(cfgSimple);

          const saveBtn = document.createElement('button');
          saveBtn.className = 'btn';
          saveBtn.type = 'button';
          saveBtn.textContent = 'Save';
          const loadBtn = document.createElement('button');
          loadBtn.className = 'btn';
          loadBtn.type = 'button';
          loadBtn.textContent = 'Load';
          loadBtn.style.marginLeft = '8px';
          const delBtn = document.createElement('button');
          delBtn.className = 'btn warn';
          delBtn.type = 'button';
          delBtn.textContent = 'Delete';
          delBtn.style.marginLeft = '8px';
          const resetBtn = document.createElement('button');
          resetBtn.className = 'btn warn';
          resetBtn.type = 'button';
          resetBtn.textContent = 'Reset to defaults';
          resetBtn.style.marginLeft = '8px';
          paneContent.appendChild(saveBtn);
          paneContent.appendChild(loadBtn);
          paneContent.appendChild(delBtn);
          paneContent.appendChild(resetBtn);

          // helper: populate selector
          function refreshTplSelect() {
            tplSelect.innerHTML = '';
            forms.forEach((t) => {
              const o = document.createElement('option');
              o.value = t.id;
              o.textContent = t.label || t.id;
              tplSelect.appendChild(o);
            });
          }
          refreshTplSelect();
          // Default the forms select to the most-recent form so reopening
          // the pane shows the last-created form by default.
          try {
            if (forms && forms.length) tplSelect.value = forms[forms.length - 1].id;
          } catch (e) {}

          function loadSelected() {
            const id = tplSelect.value;
            const t = forms.find((x) => x.id === id);
            if (!t) {
              lblInput.value = '';
              cfgTa.value = '';
              fieldsTa.value = '';
              return;
            }
            lblInput.value = t.label || '';
            try {
              const json = t.cfg ? JSON.stringify(t.cfg, null, 2) : '';
              if (typeof cfgSimple !== 'undefined' && typeof advChk !== 'undefined') {
                // If this template is a simple template object, prefer showing
                // the simple textarea; otherwise show the raw JSON in advanced.
                if (
                  t.cfg &&
                  typeof t.cfg === 'object' &&
                  t.cfg.type === 'template' &&
                  typeof t.cfg.template === 'string'
                ) {
                  cfgSimple.value = t.cfg.template;
                  cfgTa.value = json;
                  advChk.checked = false;
                  cfgTa.style.display = 'none';
                  cfgSimple.style.display = '';
                } else {
                  cfgTa.value = json;
                  cfgSimple.value = '';
                  advChk.checked = true;
                  cfgTa.style.display = '';
                  cfgSimple.style.display = 'none';
                }
              } else {
                cfgTa.value = json;
              }
            } catch (e) {
              cfgTa.value = '';
            }
            try {
              fieldsTa.value = t.fields ? JSON.stringify(t.fields, null, 2) : '';
            } catch (e) {
              fieldsTa.value = '';
            }
          }
          tplSelect.addEventListener('change', loadSelected);
          loadSelected();

          addBtn.addEventListener('click', () => {
            // Require an existing Output to be selected before creating a Template
            const outId = outSelect && outSelect.value ? outSelect.value : null;
            if (!outId) {
              alert('Please select an existing Output first.');
              return;
            }
            const baseOut = outputsMap[outId] || null;
            // Auto-populate the Label input with the selected Output's displayed name (option text)
            try {
              if (lblInput && (!lblInput.value || String(lblInput.value).trim() === '')) {
                let displayLabel = null;
                try {
                  if (
                    outSelect &&
                    typeof outSelect.selectedIndex === 'number' &&
                    outSelect.options &&
                    outSelect.options.length
                  ) {
                    displayLabel = outSelect.options[outSelect.selectedIndex].textContent || null;
                  }
                } catch (e) {}
                if (!displayLabel && baseOut && baseOut.label) displayLabel = baseOut.label;
                if (displayLabel) lblInput.value = displayLabel;
              }
            } catch (e) {}
            const id = `custom-${Date.now()}`;
            let baseCfg = null;
            try {
              if (baseOut && baseOut.cfg) {
                if (typeof baseOut.cfg === 'string')
                  baseCfg = { type: 'template', template: baseOut.cfg };
                else baseCfg = JSON.parse(JSON.stringify(baseOut.cfg));
              }
            } catch (e) {
              baseCfg = null;
            }
            const nt = {
              id,
              label: lblInput.value || (baseOut && baseOut.label) || id,
              cfg: baseCfg,
              fields: baseOut && baseOut.fields ? JSON.parse(JSON.stringify(baseOut.fields)) : [],
              outputId: outId,
            };
            forms.push(nt);
            formsMap = Object.fromEntries(forms.map((x) => [x.id, x]));
            localStorage.setItem('nfg-forms', JSON.stringify(forms));
            refreshTplSelect();
            tplSelect.value = id;
            loadSelected();
            // Also add this template as an option to existing form panes' template selects
            try {
              for (let fi = 0; fi < formConfig.length; fi++) {
                const paneEl = contents.querySelector(`.tab-pane[data-index='${fi}']`);
                if (!paneEl) continue;
                const sel = paneEl.querySelector('select');
                if (!sel) continue;
                if (!sel.querySelector(`option[value="${id}"]`)) {
                  const o = document.createElement('option');
                  o.value = id;
                  o.textContent = nt.label || id;
                  sel.appendChild(o);
                }
              }
            } catch (e) {}
            // Do NOT auto-create a form tab; templates now reference outputs separately.
          });

          // Load: create a form tab for the selected template if none exists
          loadBtn.addEventListener('click', () => {
            const id = tplSelect.value;
            if (!id) return;
            // Preserve current form values across the DOM rebuild so loading
            // a template doesn't clear data entered in other tabs.
            const allPrev = {};
            try {
              Array.from(contents.querySelectorAll('.tab-pane')).forEach((pane) => {
                const idx = pane.dataset.index;
                const form = pane.querySelector('form.generated-form');
                if (!form) return;
                const map = {};
                Array.from(form.elements).forEach((e) => {
                  if (!e.name) return;
                  const name = e.name;
                  const val = e.type === 'checkbox' ? (e.checked ? e.value || 'on' : '') : e.value;
                  if (Object.prototype.hasOwnProperty.call(map, name)) {
                    if (!Array.isArray(map[name])) map[name] = [map[name]];
                    map[name].push(val);
                  } else {
                    map[name] = val;
                  }
                });
                allPrev[idx] = map;
              });
            } catch (e) {}

            try {
              // if a tab already exists for this template, do nothing
              let exists = false;
              for (let j = 0; j < formConfig.length; j++) {
                if (formConfig[j] && formConfig[j]._templateId === id) {
                  exists = true;
                  break;
                }
              }
              if (!exists) {
                const t = forms.find((x) => x.id === id) || formsMap[id];
                const cfgCopy =
                  t && t.cfg
                    ? typeof t.cfg === 'string'
                      ? { type: 'template', template: t.cfg }
                      : JSON.parse(JSON.stringify(t.cfg))
                    : null;
                const newForm = {
                  title: (t && t.label) || id,
                  format: cfgCopy,
                  fields: t && t.fields ? JSON.parse(JSON.stringify(t.fields)) : [],
                  _templateId: id,
                };
                formConfig.push(newForm);
                formsMap = Object.fromEntries(forms.map((x) => [x.id, x]));
                // persist mapping and forms
                try {
                  persistFormMap();
                } catch (e) {}
                build();
                // restore preserved values into rebuilt panes
                try {
                  Object.keys(allPrev).forEach((nameIdx) => {
                    const pane = contents.querySelector(`.tab-pane[data-index='${nameIdx}']`);
                    if (!pane) return;
                    const form = pane.querySelector('form.generated-form');
                    if (!form) return;
                    const prev = allPrev[nameIdx] || {};
                    Object.keys(prev).forEach((nm) => {
                      try {
                        const els = Array.from(form.querySelectorAll(`[name="${CSS.escape(nm)}"]`));
                        if (!els || els.length === 0) return;
                        const pv = prev[nm];
                        if (els[0].type === 'radio') {
                          els.forEach((r) => (r.checked = r.value == pv));
                          return;
                        }
                        if (els[0].type === 'checkbox') {
                          els.forEach((c) => {
                            if (Array.isArray(pv)) c.checked = pv.includes(c.value);
                            else c.checked = !!pv && String(pv) !== 'false' && String(pv) !== '0';
                          });
                          return;
                        }
                        if (Array.isArray(pv)) {
                          for (let k = 0; k < els.length && k < pv.length; k++)
                            els[k].value = pv[k];
                        } else {
                          els[0].value = pv;
                        }
                      } catch (e) {}
                    });
                  });
                } catch (e) {}
                // activate the newly created tab (last index)
                try {
                  activateTab(formConfig.length - 1);
                } catch (e) {}
              }
            } catch (e) {}
            // keep templates pane active: after `build()` the templates tab
            // element was recreated and its dataset.index may have changed.
            // Re-query the current templates tab (.tab.right) and activate it.
            try {
              const newTplTab = tabbar.querySelector('.tab.right');
              if (newTplTab) activateTab(Number(newTplTab.dataset.index));
            } catch (e) {}
          });

          // Unload button handled elsewhere in templates pane; per-form Unload exists below when devMode enabled.

          saveBtn.addEventListener('click', () => {
            // debug removed
            const id = tplSelect.value;
            // debug special removed
            // debug removed
            const t = forms.find((x) => x.id === id);
            if (!t) return;
            t.label = lblInput.value || t.label || t.id;
            try {
              const raw = String(
                typeof advChk !== 'undefined' && advChk.checked
                  ? cfgTa.value || ''
                  : typeof cfgSimple !== 'undefined'
                  ? cfgSimple.value
                  : cfgTa.value || ''
              ).trim();
              if (!raw) {
                t.cfg = null;
              } else {
                if (raw[0] === '{' || raw[0] === '[') {
                  t.cfg = JSON.parse(raw);
                } else {
                  t.cfg = { type: 'template', template: raw };
                }
              }
            } catch (e) {
              try {
                // If advanced view is enabled, highlight cfgTa, otherwise cfgSimple
                try {
                  if (typeof advChk !== 'undefined' && advChk.checked) highlightJsonError(cfgTa, e);
                  else highlightJsonError(cfgSimple, e);
                } catch (ex) {}
              } catch (ex) {}
              alert('Invalid template config JSON: ' + e.message);
              return;
            }
            try {
              const parsedFields = fieldsTa.value.trim() ? JSON.parse(fieldsTa.value) : [];
              if (!Array.isArray(parsedFields)) throw new Error('Fields must be an array');
              t.fields = parsedFields;
            } catch (e) {
              try {
                highlightJsonError(fieldsTa, e);
              } catch (ex) {}
              alert('Invalid fields JSON: ' + e.message);
              return;
            }
            // Associate the template with the currently selected Output (if any)
            try {
              if (outSelect && outSelect.value) t.outputId = outSelect.value;
            } catch (e) {}
            // If this template maps to a default form (tpl-<index>), update that formConfig entry
            try {
              const m = /^tpl-(\d+)$/.exec(t.id);
              if (m) {
                const idx = Number(m[1]);
                // debug removed
                if (formConfig[idx]) {
                  // If the existing tab already has user-filled values, do not
                  // overwrite its fields list (avoids clearing user input).
                  let hasValues = false;
                  try {
                    const pane = contents.querySelector(`.tab-pane[data-index='${idx}']`);
                    if (pane) {
                      const f = pane.querySelector('form.generated-form');
                      if (f) {
                        Array.from(f.elements).forEach((e) => {
                          if (hasValues) return;
                          if (!e.name) return;
                          if (e.type === 'checkbox' || e.type === 'radio') {
                            if (e.checked) hasValues = true;
                          } else if (String(e.value || '').trim() !== '') {
                            hasValues = true;
                          }
                        });
                      }
                    }
                  } catch (e) {}
                  formConfig[idx].fields = JSON.parse(JSON.stringify(t.fields || []));
                  // explicitly set format to null when template cfg is null/blank
                  formConfig[idx].format = t.cfg
                    ? typeof t.cfg === 'string'
                      ? { type: 'template', template: t.cfg }
                      : JSON.parse(JSON.stringify(t.cfg))
                    : null;
                  formConfig[idx]._templateId = t.id;
                }
              } else {
                // For custom templates, if a corresponding form exists, update it too
                try {
                  for (let j = 0; j < formConfig.length; j++) {
                    if (formConfig[j] && formConfig[j]._templateId === t.id) {
                      // If this tab already has values entered by the user, avoid
                      // overwriting its `fields` to prevent clearing user input.
                      let hasValues = false;
                      try {
                        const pane = contents.querySelector(`.tab-pane[data-index='${j}']`);
                        if (pane) {
                          const f = pane.querySelector('form.generated-form');
                          if (f) {
                            Array.from(f.elements).forEach((e) => {
                              if (hasValues) return;
                              if (!e.name) return;
                              if (e.type === 'checkbox' || e.type === 'radio') {
                                if (e.checked) hasValues = true;
                              } else if (String(e.value || '').trim() !== '') {
                                hasValues = true;
                              }
                            });
                          }
                        }
                      } catch (e) {}
                      if (!hasValues) {
                        formConfig[j].fields = JSON.parse(JSON.stringify(t.fields || []));
                      }
                      formConfig[j].format = t.cfg
                        ? typeof t.cfg === 'string'
                          ? { type: 'template', template: t.cfg }
                          : JSON.parse(JSON.stringify(t.cfg))
                        : null;
                      formConfig[j].title = t.label || formConfig[j].title;
                    }
                  }
                } catch (e) {}
              }
            } catch (e) {}
            formsMap = Object.fromEntries(forms.map((x) => [x.id, x]));
            localStorage.setItem('nfg-forms', JSON.stringify(forms));
            // persist any mapping changes made by save
            try {
              persistFormMap();
            } catch (e) {}
            // preserve templates tab and selection after rebuild
            const preserveIndex = tplPane.dataset.index;
            const preserveId = t.id;
            const allPrev = captureAllFormValues();
            try {
              build();
            } catch (e) {}
            try {
              restoreAllFormValues(allPrev);
            } catch (e) {}
            try {
              activateTab(Number(preserveIndex));
              const newPane = contents.querySelector(`.tab-pane[data-index='${preserveIndex}']`);
              if (newPane) {
                const newSelect = newPane.querySelector('select');
                if (newSelect) {
                  newSelect.value = preserveId;
                  newSelect.dispatchEvent(new Event('change'));
                }
                // status appended after applying to form panes below
              }
            } catch (e) {}
            // Also trigger change on any form panes that currently have this template selected
            try {
              suppressTabActivation = true;
              for (let fi = 0; fi < formConfig.length; fi++) {
                const formPane = contents.querySelector(`.tab-pane[data-index='${fi}']`);
                if (!formPane) continue;
                const formTpl = formPane.querySelector('select');
                if (!formTpl) continue;
                if (formTpl.value === preserveId) {
                  formTpl.dispatchEvent(new Event('change'));
                }
              }
            } catch (e) {
            } finally {
              suppressTabActivation = false;
            }
            // Ensure that when saving a default tpl-<index> we render any new fields
            // immediately in the corresponding form pane. This guards against
            // timing issues in tests that assert DOM presence right after save.
            try {
              const m2 = /^tpl-(\d+)$/.exec(preserveId);
              if (m2) {
                const idx2 = Number(m2[1]);
                const pane2 = contents.querySelector(`.tab-pane[data-index='${idx2}']`);
                if (pane2) {
                  const formEl = pane2.querySelector('form.generated-form');
                  if (formEl && formConfig[idx2] && Array.isArray(formConfig[idx2].fields)) {
                    formConfig[idx2].fields.forEach((f) => {
                      try {
                        if (
                          formEl.querySelector(`[name="${CSS.escape(f.name)}"]`) ||
                          (f.type === 'steps' &&
                            formEl.querySelector(`[name="${CSS.escape(f.name + '_combined')}" ]`))
                        )
                          return;
                        const wrapper = document.createElement('div');
                        wrapper.className = 'field';
                        const labelEl = document.createElement('label');
                        labelEl.textContent = f.label || f.name;
                        wrapper.appendChild(labelEl);
                        let inputEl;
                        if (f.type === 'textarea') inputEl = document.createElement('textarea');
                        else if (f.type === 'select') {
                          inputEl = document.createElement('select');
                          (f.options || []).forEach((opt) => {
                            const o = document.createElement('option');
                            o.value = opt.value ?? opt;
                            o.textContent = opt.label ?? opt;
                            inputEl.appendChild(o);
                          });
                        } else {
                          inputEl = document.createElement('input');
                          inputEl.type = f.type || 'text';
                        }
                        inputEl.name = f.type === 'steps' ? f.name + '_combined' : f.name;
                        inputEl.autocomplete = 'off';
                        if (f.placeholder) inputEl.placeholder = f.placeholder;
                        wrapper.appendChild(inputEl);
                        formEl.appendChild(wrapper);
                      } catch (e) {}
                    });
                    try {
                      activateTab(idx2);
                    } catch (e) {}
                  }
                }
              }
            } catch (e) {}
            // re-activate templates tab and show saved status (after form panes updated)
            try {
              activateTab(Number(preserveIndex));
              const tplPane = contents.querySelector(`.tab-pane[data-index='${preserveIndex}']`);
              if (tplPane) {
                const status = document.createElement('div');
                status.className = 'meta';
                status.textContent = 'Saved';
                status.style.marginTop = '8px';
                tplPane.querySelector('.tab-content').appendChild(status);
                setTimeout(() => status.remove(), 1800);
              }
            } catch (e) {}
          });

          delBtn.addEventListener('click', () => {
            try {
              var _proceed2 = true;
              try {
                if (typeof navigator !== 'undefined' && /jsdom/i.test(navigator.userAgent)) {
                  _proceed2 = true; // auto-accept in test/jsdom environment
                } else if (typeof window.confirm === 'function') {
                  _proceed2 = !!window.confirm('Delete this form/template? This action cannot be undone.');
                }
              } catch (e) {
                _proceed2 = true;
              }
              if (!_proceed2) return;
            } catch (e) {}
            const id = tplSelect.value;
            // debug removed
            const preserveIndex = tplPane.dataset.index;
            forms = forms.filter((x) => x.id !== id);
            formsMap = Object.fromEntries(forms.map((x) => [x.id, x]));
            localStorage.setItem('nfg-forms', JSON.stringify(forms));
            // update persisted mapping after deletion
            try {
              persistFormMap();
            } catch (e) {}
            refreshTplSelect();
            loadSelected();
            // If this was a custom template that had an associated form tab, remove that tab
            try {
              if (id && id.startsWith('custom-')) {
                for (let j = formConfig.length - 1; j >= 0; j--) {
                  if (formConfig[j] && formConfig[j]._templateId === id) formConfig.splice(j, 1);
                }
              }
            } catch (e) {}
            const allPrev = captureAllFormValues();
            try {
              build();
            } catch (e) {}
            try {
              restoreAllFormValues(allPrev);
            } catch (e) {}
            // pick first available template in the templates pane (no status yet)
            try {
              activateTab(Number(preserveIndex));
              const newPane = contents.querySelector(`.tab-pane[data-index='${preserveIndex}']`);
              if (newPane) {
                const newSelect = newPane.querySelector('select');
                if (newSelect && newSelect.options.length) newSelect.selectedIndex = 0;
              }
            } catch (e) {}

            // If any form panes used the deleted template, reset them to first option
            try {
              suppressTabActivation = true;
              for (let fi = 0; fi < formConfig.length; fi++) {
                const formPane = contents.querySelector(`.tab-pane[data-index='${fi}']`);
                if (!formPane) continue;
                const formTpl = formPane.querySelector('select');
                if (!formTpl) continue;
                // if the select no longer has the previously selected value, pick first and trigger change
                if (!formTpl.querySelector(`option[value="${id}"]`)) {
                  if (formTpl.options.length) {
                    formTpl.selectedIndex = 0;
                    formTpl.dispatchEvent(new Event('change'));
                  }
                }
              }
            } catch (e) {
            } finally {
              suppressTabActivation = false;
            }

            // finally re-activate templates tab and show Deleted status
            try {
              const newTplTab = tabbar.querySelector('.tab.right');
              if (newTplTab) {
                activateTab(Number(newTplTab.dataset.index));
                const finalPane = contents.querySelector(
                  `.tab-pane[data-index='${newTplTab.dataset.index}']`
                );
                if (finalPane) {
                  const status = document.createElement('div');
                  status.className = 'meta';
                  status.textContent = 'Deleted';
                  status.style.marginTop = '8px';
                  finalPane.querySelector('.tab-content').appendChild(status);
                  setTimeout(() => status.remove(), 1800);
                }
              }
            } catch (e) {}
          });

          resetBtn.addEventListener('click', () => {
            const preserveIndex = tplPane.dataset.index;
            localStorage.removeItem('nfg-forms');
            // remove persisted per-tab form mapping as well
            try {
              localStorage.removeItem(formMapKey);
              formMap = {};
            } catch (e) {}
            forms = defaultTemplates.slice();
            formsMap = Object.fromEntries(forms.map((x) => [x.id, x]));
            refreshTplSelect();
            loadSelected();
            // restore original formConfig fields/formats for default tabs
            try {
              for (let idx = 0; idx < formConfig.length; idx++) {
                if (originalFormConfig[idx]) {
                  formConfig[idx].fields = JSON.parse(
                    JSON.stringify(originalFormConfig[idx].fields || [])
                  );
                  formConfig[idx].format = JSON.parse(
                    JSON.stringify(originalFormConfig[idx].format || null)
                  );
                  if (originalFormConfig[idx]._templateId)
                    formConfig[idx]._templateId = originalFormConfig[idx]._templateId;
                }
              }
            } catch (e) {}
            const allPrev = captureAllFormValues();
            try {
              build();
            } catch (e) {}
            try {
              restoreAllFormValues(allPrev);
            } catch (e) {}
            try {
              const newTplTab = tabbar.querySelector('.tab.right');
              if (newTplTab) {
                activateTab(Number(newTplTab.dataset.index));
                const newPane = contents.querySelector(
                  `.tab-pane[data-index='${newTplTab.dataset.index}']`
                );
                if (newPane) {
                  const newSelect = newPane.querySelector('select');
                  if (newSelect) {
                    if (newSelect.options.length) newSelect.selectedIndex = 0;
                    newSelect.dispatchEvent(new Event('change'));
                  }
                  // re-query the pane after dispatch in case the DOM was rebuilt
                  const freshPane = contents.querySelector(
                    `.tab-pane[data-index='${newTplTab.dataset.index}']`
                  );
                  const targetPane = freshPane || newPane;
                  // Do not append status here — the DOM may be rebuilt by subsequent
                  // programmatic change events. Status will be appended after all
                  // programmatic updates complete.
                }
              }
            } catch (e) {}
            // After reset, ensure form panes point to a valid template and trigger change
            try {
              suppressTabActivation = true;
              for (let fi = 0; fi < formConfig.length; fi++) {
                const formPane = contents.querySelector(`.tab-pane[data-index='${fi}']`);
                if (!formPane) continue;
                const formTpl = formPane.querySelector('select');
                if (!formTpl) continue;
                // if the currently selected option is no longer present, select first
                if (!formTpl.querySelector(`option[value="${formTpl.value}"]`)) {
                  if (formTpl.options.length) {
                    formTpl.selectedIndex = 0;
                    formTpl.dispatchEvent(new Event('change'));
                  }
                }
              }
            } catch (e) {
            } finally {
              suppressTabActivation = false;
            }
            // Ensure Templates tab remains active after programmatic changes
            try {
              const newTplTab = tabbar.querySelector('.tab.right');
              if (newTplTab) {
                activateTab(Number(newTplTab.dataset.index));
                // append status after final activation so it isn't removed by rebuild
                try {
                  const finalPane = contents.querySelector(
                    `.tab-pane[data-index='${newTplTab.dataset.index}']`
                  );
                  if (finalPane) {
                    const status = document.createElement('div');
                    status.className = 'meta';
                    status.textContent = 'Reset to defaults';
                    status.style.marginTop = '8px';
                    const container = finalPane.querySelector('.tab-content');
                    if (container) container.appendChild(status);
                    setTimeout(() => status.remove(), 1800);
                  }
                } catch (e) {}
              }
            } catch (e) {}
          });

          tplPane.appendChild(paneContent);
          contents.appendChild(tplPane);
        })();

        activateTab(0);
      }

      function activateTab(index) {
        Array.from(tabbar.children).forEach((t) =>
          t.classList.toggle('active', Number(t.dataset.index) === index)
        );
        Array.from(contents.children).forEach(
          (p) => (p.style.display = Number(p.dataset.index) === index ? '' : 'none')
        );
      }

      // Scans other tabs for values matching field names in target tab.
      // Returns array of items {name, value, fromTabIndex, fromTabTitle, found}
      function scanPopulate(targetIndex, previewContainer) {
        const targetPane = contents.querySelector(`.tab-pane[data-index='${targetIndex}']`);
        const targetForm = targetPane.querySelector('form.generated-form');
        const targetNames = Array.from(targetForm.elements)
          .map((e) => e.name)
          .filter(Boolean)
          .filter((n) => !n.endsWith('_key') && !n.endsWith('_combined'));
        const items = targetNames.map((n) => ({ name: n, candidates: [] }));

        formConfig.forEach((tab, ti) => {
          if (ti === targetIndex) return;
          const pane = contents.querySelector(`.tab-pane[data-index='${ti}']`);
          if (!pane) return;
          const form = pane.querySelector('form.generated-form');
          if (!form) return;
          targetNames.forEach((name, idx) => {
            // consider both normal inputs and a possible combined input from other tabs
            const combinedName = name + '_combined';
            const els = Array.from(
              form.querySelectorAll(
                `[name="${CSS.escape(name)}"], [name="${CSS.escape(combinedName)}"]`
              )
            );
            if (!els || els.length === 0) return;
            // Prefer a combined input if present in the source form; this
            // ensures pre-parsed values (e.g. "steps_combined") are offered
            // as candidates instead of individual per-step inputs.
            const combinedEl = els.find((e) => e.name === combinedName);
            if (combinedEl) {
              const v = combinedEl.value !== undefined ? combinedEl.value : '';
              if (String(v).trim() !== '')
                items[idx].candidates.push({ value: v, fromTab: ti, fromTitle: tab.title });
              return;
            }
            // collect candidate(s) from this tab for normal inputs
            if (els[0].type === 'radio') {
              const checked = els.find((e) => e.checked);
              if (checked)
                items[idx].candidates.push({
                  value: checked.value || '',
                  fromTab: ti,
                  fromTitle: tab.title,
                });
            } else if (els[0].type === 'checkbox') {
              const checked = els.find((e) => e.checked);
              if (checked)
                items[idx].candidates.push({
                  value: checked.value || 'on',
                  fromTab: ti,
                  fromTitle: tab.title,
                });
            } else {
              // prefer first non-empty value among matching elements
              for (const e of els) {
                if (e.value !== undefined && String(e.value).trim() !== '') {
                  items[idx].candidates.push({ value: e.value, fromTab: ti, fromTitle: tab.title });
                  break;
                }
              }
            }
          });
        });

        // render preview with multiple candidate choices per field
        previewContainer.innerHTML = '';
        items.forEach((it) => {
          const row = document.createElement('div');
          row.className = 'preview-item';
          const label = document.createElement('div');
          label.style.flex = '1';
          const name = document.createElement('div');
          name.className = 'small';
          name.textContent = it.name;
          label.appendChild(name);

          if (it.candidates.length === 0) {
            const none = document.createElement('div');
            none.className = 'meta';
            none.textContent = 'no value found';
            label.appendChild(none);
          } else {
            const list = document.createElement('div');
            // add keep-current option first (default) and show the current value
            const keepOpt = document.createElement('div');
            keepOpt.style.display = 'flex';
            keepOpt.style.alignItems = 'center';
            keepOpt.style.gap = '8px';
            keepOpt.style.padding = '2px 0';
            const keepRadio = document.createElement('input');
            keepRadio.type = 'radio';
            keepRadio.autocomplete = 'off';
            keepRadio.name = `choose-${targetIndex}-${it.name}`;
            keepRadio.value = '__keep__';
            keepRadio.checked = true;
            // determine current value from the target form
            let currentVal = '';
            try {
              const currentEls = Array.from(
                targetForm.querySelectorAll(`[name="${CSS.escape(it.name)}"]`)
              );
              if (currentEls && currentEls.length) {
                if (currentEls[0].type === 'radio') {
                  const c = currentEls.find((e) => e.checked);
                  if (c) currentVal = c.value || '';
                } else if (currentEls[0].type === 'checkbox') {
                  const c = currentEls.find((e) => e.checked);
                  if (c) currentVal = c.value || 'on';
                } else {
                  currentVal = currentEls[0].value || '';
                }
              }
            } catch (e) {
              currentVal = '';
            }
            const keepTxt = document.createElement('div');
            keepTxt.className = 'meta';
            keepTxt.textContent = `${currentVal || ''} (Keep current)`;
            keepOpt.appendChild(keepRadio);
            keepOpt.appendChild(keepTxt);
            list.appendChild(keepOpt);

            it.candidates.forEach((c, ci) => {
              const opt = document.createElement('div');
              opt.style.display = 'flex';
              opt.style.alignItems = 'center';
              opt.style.gap = '8px';
              opt.style.padding = '2px 0';
              const r = document.createElement('input');
              r.type = 'radio';
              r.autocomplete = 'off';
              r.name = `choose-${targetIndex}-${it.name}`;
              r.value = String(ci);
              const txt = document.createElement('div');
              txt.className = 'meta';
              txt.textContent = `${c.value} (from ${c.fromTitle})`;
              opt.appendChild(r);
              opt.appendChild(txt);
              list.appendChild(opt);
            });
            label.appendChild(list);
          }

          row.appendChild(label);
          previewContainer.appendChild(row);
          it._candidates = it.candidates; // store for later
        });

        // Apply selected button
        const applyBtn = document.createElement('button');
        applyBtn.className = 'btn';
        applyBtn.type = 'button';
        applyBtn.textContent = 'Apply Selected';
        applyBtn.style.marginTop = '8px';
        applyBtn.addEventListener('click', () => {
          const selections = [];
          items.forEach((it) => {
            const radios = previewContainer.querySelectorAll(
              `input[name="choose-${targetIndex}-${it.name}"]`
            );
            if (!radios || radios.length === 0) return;
            const checked = Array.from(radios).find((r) => r.checked);
            if (!checked) return;
            const ci = Number(checked.value);
            const cand = it._candidates && it._candidates[ci];
            if (cand) selections.push({ name: it.name, value: cand.value });
          });
          applyPreviewSelections(targetIndex, selections);
        });
        previewContainer.appendChild(applyBtn);

        return items;
      }

      // Generate output based on format configuration and values object
      function generateOutput(formatCfg, values) {
        if (!formatCfg) return JSON.stringify(values, null, 2);
        const tpl = formatCfg.template || '';
        if (formatCfg.type === 'template') {
          return tpl.replace(/\{([^}]+)\}/g, (_, name) => {
            // prefer explicit value (even empty string) if provided; only
            // fall back to combined input when the explicit key is absent
            const hasExplicit = values && Object.prototype.hasOwnProperty.call(values, name);
            let val = hasExplicit ? values[name] : undefined;
            if (
              !hasExplicit &&
              values &&
              Object.prototype.hasOwnProperty.call(values, name + '_combined')
            ) {
              val = values[name + '_combined'];
            }

            // If an explicit value exists, return it without reformatting.
            if (hasExplicit) {
              if (Array.isArray(val)) {
                // preserve array contents exactly (no numbering), join with newlines
                return val.join('\n');
              }
              return val !== undefined && val !== null ? String(val) : '';
            }

            // If the value is an array, strip any existing numeric prefixes
            // (e.g. "1. A") then format as a numbered list
            if (Array.isArray(val)) {
              if (val.length === 0) return '';
              const cleaned = val.map((v) =>
                String(v)
                  .replace(/^\s*(?:\d+[\.)]\s*)?(?:[-*•]\s*)?/, '')
                  .trim()
              );
              return '\n' + cleaned.map((v, i) => ` ${i + 1}. ${v}`).join('\n');
            }

            // If it's a string containing separators like '>', split and format
            if (typeof val === 'string' && val.includes('>')) {
              const parts = val
                .split('>')
                .map((s) => s.trim())
                .filter(Boolean)
                .map((p) =>
                  String(p)
                    .replace(/^\s*(?:\d+[\.)]\s*)?(?:[-*•]\s*)?/, '')
                    .trim()
                );
              if (parts.length === 0) return '';
              return '\n' + parts.map((p, i) => ` ${i + 1}. ${p}`).join('\n');
            }

            // fallback: string/number or empty
            return val !== undefined && val !== null ? String(val) : '';
          });
        }
        if (formatCfg.type === 'sprintf') {
          // support Python-style named tokens: %(name)s
          return tpl.replace(/%\(([^)]+)\)s/g, (_, name) =>
            values[name] !== undefined ? values[name] : ''
          );
        }
        // fallback: if formatCfg is string treat as template
        if (typeof formatCfg === 'string') {
          return formatCfg.replace(/\{([^}]+)\}/g, (_, name) =>
            values[name] !== undefined ? values[name] : ''
          );
        }
        return JSON.stringify(values, null, 2);
      }

      function applyPreviewSelections(targetIndex, selections) {
        const targetPane = contents.querySelector(`.tab-pane[data-index='${targetIndex}']`);
        const targetForm = targetPane.querySelector('form.generated-form');
        selections.forEach((sel) => {
          // resolve field config for this target tab + field name
          const fieldCfg =
            formConfig[targetIndex] && formConfig[targetIndex].fields
              ? formConfig[targetIndex].fields.find((f) => f.name === sel.name)
              : null;
          // find the combined input for steps fields (if any) so we can
          // mirror combined values into the top input when applying selections
          const combinedInput = targetForm.querySelector(
            `[name="${CSS.escape(sel.name + '_combined')}"]`
          );
          // If this field's type is 'steps' and there are no inputs yet, create items
          if (fieldCfg && fieldCfg.type === 'steps') {
            const parts = String(sel.value || '')
              .split('>')
              .map((s) => s.trim())
              .filter(Boolean);
            const existing = Array.from(
              targetForm.querySelectorAll(`[name="${CSS.escape(sel.name)}"]`)
            );
            const container = targetForm.querySelector(`.steps-container[data-name="${sel.name}"]`);
            const list = container && container.querySelector('.steps-list');
            if (parts.length > 1) {
              // clear existing list
              if (list) list.innerHTML = '';
              // create inputs per part
              parts.forEach((p) => {
                if (list) {
                  if (p.includes('=>')) {
                    const [k, ...rest] = p.split('=>');
                    const val = rest.join('=>').trim();
                    createStepRow(sel.name, { key: k.trim(), val }, container, list);
                  } else {
                    createStepRow(sel.name, p, container, list);
                  }
                }
              });
              // Also update the combined input so the combined representation
              // is visible to the user after applying the selection.
              try {
                if (combinedInput) combinedInput.value = sel.value;
              } catch (e) {}
            }
          }

          const els = Array.from(targetForm.querySelectorAll(`[name="${CSS.escape(sel.name)}"]`));
          if (!els || els.length === 0) return;
          // radios
          if (els[0].type === 'radio') {
            els.forEach((r) => {
              r.checked = r.value == sel.value;
            });
            return;
          }
          // checkboxes
          if (els[0].type === 'checkbox') {
            els.forEach((c) => {
              c.checked = !!sel.value && String(sel.value) !== 'false' && String(sel.value) !== '0';
            });
            return;
          }
          // For steps fields, if sel.value contains '>' distribute values
          if (fieldCfg && fieldCfg.type === 'steps' && String(sel.value || '').includes('>')) {
            const parts = String(sel.value || '')
              .split('>')
              .map((s) => s.trim())
              .filter(Boolean);
            // locate container/list up-front so it's available to the entire block
            const container = targetForm.querySelector(`.steps-container[data-name="${sel.name}"]`);
            const list = container && container.querySelector('.steps-list');
            // ensure we have enough inputs
            if (parts.length > els.length) {
              for (let i = els.length; i < parts.length; i++) {
                if (list) createStepRow(sel.name, '', container, list);
              }
            }
            const newEls = Array.from(
              targetForm.querySelectorAll(`[name="${CSS.escape(sel.name)}"]`)
            );
            const newKeys = Array.from(
              targetForm.querySelectorAll(`[name="${CSS.escape(sel.name + '_key')}"]`)
            );
            parts.forEach((p, idx) => {
              let key = '';
              let val = p;
              if (p.includes('=>')) {
                const [k, ...rest] = p.split('=>');
                key = k.trim();
                val = rest.join('=>').trim();
              }
              if (newEls[idx]) newEls[idx].value = val;
              if (newKeys[idx]) {
                if (key) newKeys[idx].value = key;
                else if (container && container.dataset) {
                  if (container.dataset.keyMode === 'numbered')
                    newKeys[idx].value = String(idx + 1);
                  else if (container.dataset.keyMode === 'bullet') newKeys[idx].value = '-';
                }
              }
            });
            // mirror the combined string into the top combined input if present
            try {
              if (combinedInput) combinedInput.value = sel.value;
            } catch (e) {}
            return;
          }

          // text/select/textarea - set first element's value
          const e = els[0];
          try {
            e.value = sel.value;
            // if this is a steps field, also update the combined input
            try {
              if (fieldCfg && fieldCfg.type === 'steps' && combinedInput)
                combinedInput.value = sel.value;
            } catch (e) {}
          } catch (e) {}
        });
      }

      // initial build
      build();

      // Theme handling: toggle dark mode and persist choice
      (function () {
        const key = 'nfg-theme';
        const btn = document.getElementById('themeToggle');
        function applyTheme(t) {
          if (t === 'dark') document.documentElement.classList.add('dark');
          else document.documentElement.classList.remove('dark');
          if (btn) btn.textContent = t === 'dark' ? 'Light' : 'Dark';
        }
        const saved =
          localStorage.getItem(key) ||
          (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
            ? 'dark'
            : 'light');
        applyTheme(saved);
        if (btn)
          btn.addEventListener('click', () => {
            const isDark = document.documentElement.classList.toggle('dark');
            const next = isDark ? 'dark' : 'light';
            localStorage.setItem(key, next);
            if (btn) btn.textContent = isDark ? 'Light' : 'Dark';
          });
      })();
    </script>
  </body>
</html>
